<h1>The 2D rendering context</h1>
<pre class='metadata'>
Shortname: Canvas 2D
Level: 2
Status: ED
ED: http://www.w3.org/html/wg/drafts/2dcontext/master/
TR: http://www.w3.org/TR/2dcontext2/
Previous Version: http://www.w3.org/TR/2013/WD-2dcontext2-20131029/
Group: HTML
Ignored Terms: float32array, float64array, indexsizeerror, DOMString, SVGMatrix
Link Defaults: css-color-3 (property) color, css-fonts-3 (descriptor) font-weight
Editor: Rik Cabanier, Adobe Systems Inc., cabanier@adobe.com
Editor: Jatinder Mann, Microsoft Corporation, jmann@microsoft.com
Editor: Jay Munro, Microsoft Corporation, jaymunro@microsoft.com
Editor: Tom Wiltzius, Google Inc., wiltzius@google.com
Former Editor: Ian Hickson, Google Inc., ian@hixie.ch
Abstract: This specification defines the 2D Context for the HTML canvas element. The 2D Context provides objects, methods, and properties to draw and manipulate graphics on a canvas drawing surface.
Mailing List: public-canvas-api@w3.org
Mailing List Archives: http://lists.w3.org/Archives/Public/public-canvas-api/

</pre>

<style type="text/css">
a[data-link-type=element]::before,span[data-link-type=element]::before {
  content: '<';
}
a[data-link-type=element]::after,span[data-link-type=element]::after {
  content: '>';
}
dl.domintro {
padding: 0.5em 1em;
border: none;
background: #E9FBE9;
border: 1px solid lightgray;
}
dl.domintro:before {
display: table;
margin: -1.5em -0.5em -0em auto;
width: auto;
content: 'This definition is non-normative. Implementation requirements are given below this definition.';
color: #606060;
border: 1px solid lightgray;
background: white;
padding: 0 0.25em;
font-size: .9em;
}
.h-entry {
  max-width: 65em;
}
</style>

<h2 id="2dcontext" title="IDL of the 2D graphics context">The 2D rendering context</h2>

<pre class="idl">
typedef (HTMLImageElement or
         HTMLVideoElement or
         HTMLCanvasElement or
         CanvasRenderingContext2D <!-- or
         ImageBitmap -->) <dfn>CanvasImageSource</dfn>;

enum CanvasFillRule { "nonzero", "evenodd" };

[Constructor(optional unsigned long width, unsigned long height), Exposed=Window,Worker]
interface CanvasRenderingContext2D {

  // back-reference to the canvas
  readonly attribute HTMLCanvasElement canvas;

  // canvas dimensions
  attribute unsigned long width;
  attribute unsigned long height;

  // for contexts that aren't directly <span data-x="concept-canvas-fixed">fixed</span> to a specific canvas
  void commit(); // push the image to the <span>output bitmap</span>

  // state
  void save(); // push state on state stack
  void restore(); // pop state stack and restore state

  // transformations (default transform is the identity matrix)
  attribute SVGMatrix currentTransform;
  void scale(unrestricted double x, unrestricted double y);
  void rotate(unrestricted double angle);
  void translate(unrestricted double x, unrestricted double y);
  void transform(unrestricted double a, unrestricted double b, unrestricted double c, 
                 unrestricted double d, unrestricted double e, unrestricted double f);
  void setTransform(unrestricted double a, unrestricted double b, unrestricted double c, 
                    unrestricted double d, unrestricted double e, unrestricted double f);
  void resetTransform();

  // compositing
  attribute unrestricted double globalAlpha; // (default 1.0)
  attribute DOMString globalCompositeOperation; // (default source-over)

  // image smoothing
  attribute boolean imageSmoothingEnabled; // (default true)

  // colors and styles (see also the CanvasDrawingStylesinterface)
  attribute (DOMString or CanvasGradient or CanvasPattern) strokeStyle; // (default black)
  attribute (DOMString or CanvasGradient or CanvasPattern) fillStyle; // (default black)
  CanvasGradient createLinearGradient(double x0, double y0, double x1, double y1);
  CanvasGradient createRadialGradient(double x0, double y0, double r0, double x1, 
                                      double y1, double r1);
  CanvasPattern createPattern(CanvasImageSource image, 
                              [TreatNullAs=EmptyString] DOMString repetition);

  // shadows
  attribute unrestricted double shadowOffsetX; 
  attribute unrestricted double shadowOffsetY; 
  attribute unrestricted double shadowBlur; // (default 0)
  attribute DOMString shadowColor; // (default transparent black)

  // rects
  void clearRect(unrestricted double x, unrestricted double y, unrestricted double w, 
                 unrestricted double h);
  void fillRect(unrestricted double x, unrestricted double y, unrestricted double w, 
                unrestricted double h);
  void strokeRect(unrestricted double x, unrestricted double y, unrestricted double w, 
                  unrestricted double h);

  // path API (see also CanvasPathMethods)
  void beginPath();
  void fill(optional CanvasFillRule fillRule = "nonzero");
  void <a title="fill-path2d">fill(Path2D path, optional CanvasFillRule fillRule = "nonzero")</a>;
  void stroke();
  void stroke(Path2D path);

  void drawFocusIfNeeded(Element elem);
  void drawFocusIfNeeded(Path2D path, Element elem);
 
  boolean drawCustomFocusRing(Element element);
  boolean drawCustomFocusRing(Path2D path, Element element);
  void scrollPathIntoView();
  void scrollPathIntoView(Path2D path);
  void clip(optional CanvasFillRule fillRule = "nonzero");
  void clip(Path2D path, optional CanvasFillRule fillRule = "nonzero");
  void resetClip();
  boolean isPointInPath(unrestricted double x, unrestricted double y, 
                        optional CanvasFillRule fillRule = "nonzero");
  boolean isPointInPath(Path2D path, unrestricted double x, unrestricted double y, 
                        optional CanvasFillRule fillRule = "nonzero");
  boolean isPointInStroke(unrestricted double x, unrestricted double y);
  boolean isPointInStroke(Path2D path, unrestricted double x, unrestricted double y);
 
  // text (see also the CanvasDrawingStyles< interface)
  void fillText(DOMString text, unrestricted double x, unrestricted double y, 
                optional unrestricted double maxWidth);
  void strokeText(DOMString text, unrestricted double x, unrestricted double y, 
                  optional unrestricted double maxWidth);
  // TextMetrics
  void measureText(DOMString text);
 
  // drawing images
  void drawImage(CanvasImageSource image, unrestricted double dx, unrestricted double dy);
  void drawImage(CanvasImageSource image, unrestricted double dx, unrestricted double dy, 
                 unrestricted double dw, unrestricted double dh);
  void drawImage(CanvasImageSource image, unrestricted double sx, unrestricted double sy, 
                 unrestricted double sw, unrestricted double sh, unrestricted double dx, 
                 unrestricted double dy, unrestricted double dw, unrestricted double dh);
 
  // hit regions
  void addHitRegion(optional HitRegionOptions options);
  void removeHitRegion(DOMString id);
  void clearHitRegions();
  
  // pixel manipulation
  ImageData createImageData(double sw, double sh);
  ImageData createImageData(ImageData sdata);
  ImageData getImageData(double sx, double sy, double sw, double sh);
  void putImageData(ImageData sdata, double dx, double dy);
  void putImageData(ImageData sdata, double dx, double dy, double dirtyX, double dirtyY, 
                    double dirtyWidth, double dirtyHeight);
};

[NoInterfaceObject, Exposed=Window,Worker]
interface CanvasDrawingStyles {
  // line caps/joins
  attribute unrestricted double lineWidth; // (default 1)
  attribute DOMString lineCap; // "butt", "round", "square" (default "butt")
  attribute DOMString lineJoin; // "round", "bevel", "miter" (default "miter")
  attribute unrestricted double miterLimit; // (default 10)

  // dashed lines
  void setLineDash</span>(sequence&lt;unrestricted double> segments); // default empty
  sequence&lt;unrestricted double> getLineDash();
  attribute unrestricted double lineDashOffset;

  // text
  attribute DOMString font; // (default 10px sans-serif)
  attribute DOMString textAlign; // "start", "end", "left", "right", "center" (default: "start")
  attribute DOMString textBaseline; // "top", "hanging", "middle", "alphabetic", "ideographic", "bottom" (default: "alphabetic")
  attribute DOMString direction; // "ltr", "rtl", "inherit" (default: "inherit")
};

[NoInterfaceObject, Exposed=Window,Worker]
interface CanvasPathMethods {
  // shared path API methods
  void <span data-x="dom-context-2d-closePath">closePath</span>();
  void <span data-x="dom-context-2d-moveTo">moveTo</span>(unrestricted double x, unrestricted double y);
  void <span data-x="dom-context-2d-lineTo">lineTo</span>(unrestricted double x, unrestricted double y);
  void <span data-x="dom-context-2d-quadraticCurveTo">quadraticCurveTo</span>(unrestricted double cpx, unrestricted double cpy, unrestricted double x, unrestricted double y);
  void <span data-x="dom-context-2d-bezierCurveTo">bezierCurveTo</span>(unrestricted double cp1x, unrestricted double cp1y, unrestricted double cp2x, unrestricted double cp2y, unrestricted double x, unrestricted double y);
  void <span data-x="dom-context-2d-arcTo">arcTo</span>(unrestricted double x1, unrestricted double y1, unrestricted double x2, unrestricted double y2, unrestricted double radius); 
  void <span data-x="dom-context-2d-rect">rect</span>(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void <span data-x="dom-context-2d-arc">arc</span>(unrestricted double x, unrestricted double y, unrestricted double radius, unrestricted double startAngle, unrestricted double endAngle, optional boolean anticlockwise = false); <!-- see ARC-ORDER note below -->
  void <span data-x="dom-context-2d-ellipse">ellipse</span>(unrestricted double x, unrestricted double y, unrestricted double radiusX, unrestricted double radiusY, unrestricted double rotation, unrestricted double startAngle, unrestricted double endAngle, optional boolean anticlockwise = false); 
};

[Exposed=Window,Worker]
interface CanvasGradient {
  // opaque object
  void addColorStop(double offset, DOMString color);
};

[Exposed=Window,Worker]
interface CanvasPattern {
  // opaque object
  void setTransform(SVGMatrix transform);
};

[Exposed=Window,Worker]
interface TextMetrics {
  // x-direction
  readonly attribute double width; // advance width
  readonly attribute double actualBoundingBoxLeft;
  readonly attribute double actualBoundingBoxRight;

  // y-direction
  readonly attribute double fontBoundingBoxAscent;
  readonly attribute double fontBoundingBoxDescent;
  readonly attribute double actualBoundingBoxAscent;
  readonly attribute double actualBoundingBoxDescent;
  readonly attribute double emHeightAscent;
  readonly attribute double emHeightDescent;
  readonly attribute double hangingBaseline;
  readonly attribute double alphabeticBaseline;
  readonly attribute double ideographicBaseline;
};

dictionary HitRegionOptions {
  Path2D? path = null;
  CanvasFillRule fillRule = "nonzero";
  SVGMatrix? transform = null;
  DOMString id = "";
  DOMString? parentID = null;
  DOMString cursor = "inherit";
  // for control-backed regions:
  Element? control = null;
};

[Constructor(unsigned long sw, unsigned long sh),
 Constructor(Uint8ClampedArray data, unsigned long sw1, optional unsigned long sh1),
 Exposed=Window,Worker]
interface ImageData {
  readonly attribute unsigned long width;
  readonly attribute unsigned long height;
  readonly attribute Uint8ClampedArray data;
};

[Constructor(optional Element scope), Exposed=Window,Worker]
interface <dfn>DrawingStyle</dfn> 
{ };
DrawingStyle implements CanvasDrawingStyles;

[Constructor
 Constructor(Path2D path),
 Constructor(Path2D[] paths, optional CanvasFillRule fillRule = "nonzero"),
 Constructor(DOMString d), Exposed=Window,Worker]
interface Path2D {
  void addPath(Path2D path, optional SVGMatrix? transformation = null);
};

Path2D implements CanvasPathMethods;
</pre>
  <dl class="domintro">

   <dt><var data-x="">context</var> = <var data-x="">canvas</var>.<code>getContext</code>('<span>2d</span>')</dt>

   <dd>

    <p>Returns a <a interface>CanvasRenderingContext2D</a> object that is permanently bound to a
    particular <code>canvas</code> element.</p>

   </dd>

   <dt><var data-x="">context</var> = new <a interface>CanvasRenderingContext2D</a>( [ <var data-x="">width</var>, <var data-x="">height</var> ] )</dt>

   <dd>

    <p>Returns an unbound <a interface>CanvasRenderingContext2D</a> object with an implied bitmap with
    the given dimensions in CSS pixels (300x150, if the arguments are omitted).</p>

   </dd>

   <dt><var data-x="">context</var>.<a link-for=CanvasRenderingContext2D link-type=attribute>canvas</a></dt>

   <dd>

    <p>Returns the <code>canvas</code> element, if the rendering context was obtained using the
    <code>getContext()</code> method.</p>

   </dd>

   <dt><var data-x="">context</var>.<a>width</a></dt>
   <dt><var data-x="">context</var>.<a>height</a></dt>

   <dd>

    <p>Return the dimensions of the bitmap, in CSS pixels.</p>

    <p>Can be set, to update the bitmap's dimensions. If the rendering context is bound to a canvas,
    this will also update the canvas' intrinsic dimensions.</p>

   </dd>

   <dt><var data-x="">context</var>.<a>commit()</a></dt>

   <dd>

    <p>If the rendering context is bound to a <code>canvas</code>, display the current frame.</p>

   </dd>

  </dl>

 <div class="impl">

  <p>A <a interface>CanvasRenderingContext2D</a> object can be obtained in two ways: the <code
  data-x="dom-canvas-getContext">getContext()</code> method on a <a link-for=CanvasRenderingContext2D link-type=attribute>canvas</a> element (which
  invokes the <span>2D context creation algorithm</span>), and the <a>CanvasRenderingContext2D()</a> constructor.</p>

  <p>A <a interface>CanvasRenderingContext2D</a> object has a <dfn>scratch bitmap</dfn> and can be bound
  to an <dfn>output bitmap</dfn>. These are initialised when the object is created, and can be
  subsequently adjusted when the rendering context is <span
  data-x="concept-canvas-binding-steps">bound</span> or <span
  data-x="concept-canvas-unbinding-steps">unbound</span>. In some cases, these bitmaps are the same
  underlying bitmap. In general, the <span>scratch bitmap</span> is what scripts interact with, and
  the <span>output bitmap</span> is what is being displayed. These bitmaps always have the same
  dimensions.</p>

<!--ADD-TOPIC:Security-->
  <p>Each such bitmap has an <dfn>origin-clean</dfn> flag,
  which can be set to true or false. Initially, when one of these bitmaps is created, its <span
  data-x="concept-canvas-origin-clean">origin-clean</span> flag must be set to true.</p>
<!--REMOVE-TOPIC:Security-->

  <p>These bitmaps also have a <a>hit region list</a>, which is described in a later section.
  Initially, this list is empty. <span data-x="scratch bitmap">Scratch bitmaps</span> also have a
  <dfn>list of pending interface actions</dfn>, which can contain instructions to draw the user's
  attention to a location on the bitmap, and instructions to scroll to a location on the bitmap.
  Initially, this list is also empty.</p>

  <p>The <a interface>CanvasRenderingContext2D</a> 2D rendering context represents a flat linear
  Cartesian surface whose origin (0,0) is at the top left corner, with the coordinate space having
  <var>x</var> values increasing when going right, and <var>y</var> values
  increasing when going down. The <var>x</var>-coordinate of the right-most edge is equal to
  the width of the rendering context's <span>scratch bitmap</span> in CSS pixels; similarly, the
  <var>y</var>-coordinate of the bottom-most edge is equal to the height of the rendering
  context's <span>scratch bitmap</span> in CSS pixels.</p>

  <p>The size of the coordinate space does not necessarily represent the size of the actual bitmaps
  that the user agent will use internally or during rendering. On high-definition displays, for
  instance, the user agent may internally use bitmaps with two device pixels per unit in the
  coordinate space, so that the rendering remains at high quality throughout. Anti-aliasing can
  similarly be implemented using over-sampling with bitmaps of a higher resolution than the final
  image on the display.</p>

  <hr>

  <p>The <dfn>2D context creation algorithm</dfn>, which is passed a <var>target</var> (a
  <code>canvas</code> element), consists of running the following steps:</p>

  <ol>

   <li><p>Create a new <a interface>CanvasRenderingContext2D</a> object.</p></li>

   <li><p>Initialise its <a link-for=CanvasRenderingContext2D link-type=attribute><code>canvas</code></a> attribute to point to
   <var>target</var>.</p></li>

   <li><p>Let the new <a interface>CanvasRenderingContext2D</a> object's <span>output bitmap</span> and
   <span>scratch bitmap</span> both be the same bitmap as <var>target</var>'s bitmap (so
   that they are shared).</p></li>

   <li><p><a>Set bitmap dimensions</a> to the
   numeric values of <var>target</var>'s <a link-for=CanvasRenderingContext2D link-type=attribute>width</a> 
   and <a link-for=CanvasRenderingContext2D link-type=attribute>height</a> content attributes.</p></li>

   <li><p>Return the new <a interface>CanvasRenderingContext2D</a> object.</p></li>

  </ol>

  <hr>

  <p>The <dfn dfn-type=constructor dfn-for=CanvasRenderingContext2D>CanvasRenderingContext2D()</dfn> constructor, when
  invoked, must run the following steps:</p>

  <ol>

   <li><p>Create a new <a interface>CanvasRenderingContext2D</a> object.</p></li>

   <li><p>Initialise its <a link-for=CanvasRenderingContext2D link-type=attribute><code>canvas</code></a> attribute to
   null.</p></li>

   <li><p>Let the new <a interface>CanvasRenderingContext2D</a> object's <span>scratch bitmap</span> be
   a new bitmap.</p></li>

   <li><p>If the constructor was called with arguments, let <var>width</var> and <var>height</var> be the first
  and second arguments, respectively. Otherwise, let <var>width</var> and <var>height</var> be 300 and 150, respectively.</p></li>

   <li><p><a>set bitmap dimensions</a> to <var>width</var> and <var>height</var>.</p></li>

   <li><p>Let the new <a interface>CanvasRenderingContext2D</a> object have no <span>output
   bitmap</span>.</p></li>


   <li><p>Return the new <a interface>CanvasRenderingContext2D</a> object.</p></li>

  </ol>

  <hr>

  <p>When the user agent is required to <dfn>commit the scratch bitmap</dfn> for a rendering
  context, it must run the following steps:

  <ol>

   <li><p>Let <var>bitmap copy</var> be a copy of the rendering context's <span>scratch
   bitmap</span>.</p></li>

<!--ADD-TOPIC:Security-->
   <li><p>Let <var>origin-clean flag copy</var> be a copy of the rendering context's
   <span>scratch bitmap</span>'s <span data-x="concept-canvas-origin-clean">origin-clean</span>
   flag.</p></li>
<!--REMOVE-TOPIC:Security-->

   <li><p>Let <var>hit region list copy</var> be a copy of the rendering context's
   <span>scratch bitmap</span>'s <a>hit region list</a>.</p></li>

   <li><p>Let <var>list of pending interface actions copy</var> be a copy of the rendering
   context's <span>scratch bitmap</span>'s <span>list of pending interface actions</span>.</p></li>

   <li><p>Empty the <span>scratch bitmap</span>'s <span>list of pending interface actions</span>.</p></li>

   <li><p>If the rendering context has no <span>output bitmap</span>, abort these steps.</p></li>

   <li><p>Let <var>output bitmap</var> be the rendering context's <span>output
   bitmap</span>.</p></li>

   <li><p>Let <a link-for=CanvasRenderingContext2D link-type=attribute><var>canvas</var></a> be the <code>canvas</code> element to which the rendering
   context was most recently <span data-x="concept-canvas-binding-steps">bound</span>.</p></li>

   <li>

    <p><span>Queue a task</span> associated with <var>canvas</var>' <code>Document</code>
    to perform the following substeps:</p>

    <ol>

     <li><p>Overwrite <var>output bitmap</var> with <var>bitmap
     copy</var>.</p></li>

<!--ADD-TOPIC:Security-->
     <li><p>Overwrite <var>output bitmap</var>'s <span
     data-x="concept-canvas-origin-clean">origin-clean</span> flag with <var>origin-clean
     flag copy</var>.</p></li>
<!--REMOVE-TOPIC:Security-->

     <li><p>Overwrite <var>output bitmap</var>'s <a>hit region list</a> with <var
     data-x="">hit region list copy</var>.</p></li>

     <li><p>Follow the directions in the <var>list of pending interface actions
     copy</var>.</p></li>

    </ol>

   </li>

  </ol>

  <p>The algorithm above must use the <dfn>canvas updating task source</dfn> (which is just used by
  this algorithm).</p>

  <p>The <dfn dfn-for=CanvasRenderingContext2D dfn-type=method><code>commit()</code></dfn> method must run the
  following steps:</p>

  <ol>

   <li><p>If the rendering context's <span data-x="concept-canvas-context-bitmap-mode">context bitmap
   mode</span> is <span data-x="concept-canvas-bound">fixed</span>, throw an
   <code>InvalidStateError</code> exception and abort these steps.</p></li>

   <li><p><span>Commit the scratch bitmap</span> for the rendering context.</p></li>

  </ol>

  <p class="note">The <span>scratch bitmap</span> is only <span data-x="commit the scratch
  bitmap">committed</span> when the <a link-for=CanvasRenderingContext2D link-type=method>commit()</a> method is
  called. (This doesn't matter for <code>canvas</code> elements in <span
  data-x="concept-canvas-direct-2d">direct-2d</span> mode, since there the <span>scratch
  bitmap</span> is also the <code>canvas</code> element's bitmap so every drawing operation is
  immediately drawn.)</p>

  <hr>

  <p>When the user agent is to <dfn>set bitmap dimensions</dfn> to <var>width</var> and <var>height</var>, it must run the
  following steps:</p>

  <ol>

   <li><p><span>Reset the rendering context to its default state</span>.</p></li>

   <li><p>Clear the <span>scratch bitmap</span>'s <a>hit region list</a> and its <span>list of
   pending interface actions</span>.</p></li>

   <li><p>Resize the <span>scratch bitmap</span> to the new <var>width</var> and <var
   data-x="">height</var> and clear it to fully transparent black.</p></li>

   <li><p>If the rendering context has an <span>output bitmap</span>, and the <span>scratch
   bitmap</span> is a different bitmap than the <span>output bitmap</span>, then resize the
   <span>output bitmap</span> to the new <var>width</var> and <var>height</var>
   and clear it to fully transparent black.</p></li>

   <li>

    <p>If the rendering context's <span data-x="concept-canvas-context-bitmap-mode">context bitmap
    mode</span> is <span data-x="concept-canvas-fixed">fixed</span>, then run these substeps:</p>

    <ol>

     <li><p>Let <var>canvas</var> be the <code>canvas</code> element to which the rendering
     context's <a link-for=CanvasRenderingContext2D link-type=attribute><code>canvas</code></a> attribute was initialized.</p></li>

     <li><p>If the rendering context's <span data-x="concept-canvas-context-bitmap-mode">context
     bitmap mode</span> is <span data-x="concept-canvas-fixed">fixed</span> and the numeric value of
     the <var>canvas</var>' <a link-for=CanvasRenderingContext2D link-type=attribute>width</a> content attribute
     differs from <var>width</var>, then set <var>canvas</var>' <a link-for=CanvasRenderingContext2D link-type=attribute>width</a> 
     content attribute to the shortest possible string
     representing <var>width</var> as a <span>valid non-negative integer</span>.</p></li>

     <li><p>If the rendering context's <span data-x="concept-canvas-context-bitmap-mode">context
     bitmap mode</span> is <span data-x="concept-canvas-fixed">fixed</span> and the numeric value of
     the <var>canvas</var>' <a link-for=CanvasRenderingContext2D link-type=attribute>height</a> content attribute
     differs from <var>height</var>, then set <var>canvas</var>' <a link-for=CanvasRenderingContext2D link-type=attribute>height</a> 
     content attribute to the shortest possible strings
     representing <var>height</var> as a <span>valid non-negative integer</span>.</p></li>

    </ol>

   </li>

  </ol>

  <div class="example">
   <p>Only one square appears to be drawn in the following example:</p>
   <pre>// canvas is a reference to a &lt;canvas> element
var context = canvas.getContext('2d');
context.fillRect(0,0,50,50);
canvas.setAttribute('width', '300'); // clears the canvas
context.fillRect(0,100,50,50);
canvas.width = canvas.width; // clears the canvas
context.fillRect(100,0,50,50); // only this square remains</pre>
  </div>

  <hr>

  <p>When the user agent is to run the <dfn>unbinding
  steps</dfn> for a rendering context, it must run the following steps:</p>

  <ol>

   <li><p><span>Reset the rendering context to its default state</span>.</p></li>

   <li><p>Clear the <span>scratch bitmap</span>'s <a>hit region list</a> and its <span>list of
   pending interface actions</span>.</p></li>

   <li><p>Clear the <a interface>CanvasRenderingContext2D</a> object's <span>scratch bitmap</span> to a
   transparent black.</p></li>

<!--ADD-TOPIC:Security-->
   <li><p>Set the <a interface>CanvasRenderingContext2D</a> object's <span>scratch bitmap</span>'s 
   <a>origin-clean</a> flag to true.</p></li>
<!--REMOVE-TOPIC:Security-->

   <li><p>Let the <a interface>CanvasRenderingContext2D</a> object have no <span>output
   bitmap</span>.</p></li>

  </ol>

  <p>When the user agent is to run the <dfn>binding steps</dfn>
  to bind the rendering context to the <code>canvas</code> element <var>target</var>, it
  must run the following steps:</p>

  <ol>

   <li><p><span>Reset the rendering context to its default state</span>.</p></li>

   <li><p>Clear the <span>scratch bitmap</span>'s <a>hit region list</a> and its <span>list of
   pending interface actions</span>.</p></li>

   <li><p>Resize the <a interface>CanvasRenderingContext2D</a> object's <span>scratch bitmap</span> to
   the dimensions of <var>target</var>'s bitmap and clear it to fully transparent
   black.</p></li>

<!--ADD-TOPIC:Security-->
   <li><p>Set the <a interface>CanvasRenderingContext2D</a> object's <span>scratch bitmap</span>'s 
   <a>origin-clean</a> flag to true.</p></li>
<!--REMOVE-TOPIC:Security-->

   <li><p>Let the <a interface>CanvasRenderingContext2D</a> object's <span>output bitmap</span> be 
   <var>target</var>'s bitmap.</p></li>

  </ol>

  <hr>

  <p>The <dfn dfn-for=CanvasRenderingContext2D dfn-type=attribute><code>canvas</code></dfn> attribute must return the
  value it was initialised to when the object was created.</p>

  <p>The <dfn dfn-for=CanvasRenderingContext2D dfn-type=attribute><code>width</code></dfn> attribute, on getting, must
  return the width of the rendering context's <span>scratch bitmap</span>, in CSS pixels. On
  setting, it must <a>set bitmap dimensions</a>
  to the new value and the current height of the rendering context's <span>scratch bitmap</span> in
  CSS pixels, respectively.</p>

  <p>The <dfn dfn-for=CanvasRenderingContext2D dfn-type=attribute><code>height</code></dfn> attribute, on getting, must
  return the height of the rendering context's <span>scratch bitmap</span>, in CSS pixels. On
  setting, it must <a>set bitmap dimensions</a>
  to the current width of the rendering context's <span>scratch bitmap</span> in CSS pixels and the
  new value, respectively.</p>

  <hr>

  <p>Except where otherwise specified, for the 2D context interface, <strong>any method call with a
  numeric argument whose value is infinite or a NaN value must be ignored</strong>.</p>

  <p>Whenever the CSS value ''currentColor'' is used as a color in the
  <a interface>CanvasRenderingContext2D</a> API, the "computed value of the 'color' property" for the
  purposes of determining the computed value of the ''currentColor'' keyword is
  the value described by the appropriate entry in the following list:</p>

  <dl>

   <dt>If the rendering context's <span>context bitmap mode</span> is <span>fixed</span> and the <code>canvas</code>
   element is <span>being rendered</span></dt>

   <dd><p>The "computed value of the 'color' property" for the purposes of determining the computed
   value of the ''currentColor'' keyword is the computed value of the 'color'
   property on the <code>canvas</code> element at the time that the color is specified (e.g. when
   the appropriate attribute is set, or when the method is called; not when the color is rendered or
   otherwise used). <a href="#refsCSSCOLOR">[CSSCOLOR]</a></p></dd>

   <dt>In all other cases</dt>

   <dd><p>The "computed value of the 'color' property" for the purposes of determining the computed
   value of the ''currentColor'' keyword is fully opaque black.</p></dd>

  </dl>

  <p>In the case of <code data-x="dom-canvasgradient-addColorStop">addColorStop()</code> on
  <code>CanvasGradient</code>, the "computed value of the 'color' property" for the purposes of
  determining the computed value of the <code data-x="">currentColor</code> keyword is always fully
  opaque black (there is no associated element). <a href="#refsCSSCOLOR">[CSSCOLOR]</a></p>

  <p class="note">This is because <code>CanvasGradient</code> objects are
  <code>canvas</code>-neutral &mdash; a <code>CanvasGradient</code> object created by one
  <code>canvas</code> can be used by another, and there is therefore no way to know which is the
  "element in question" at the time that the color is specified.</p>

  <p class="note">Similar concerns exist with font-related properties; the rules for those are
  described in detail in the relevant section below.</p>

  </div>

  <hr>

  <p>The <dfn dfn-type=enum><code>CanvasFillRule</code></dfn> enumeration is used to select the <dfn>fill rule</dfn>
  algorithm by which to determine if a point is inside or outside a path.</p>

  <p>The value "<dfn value for=CanvasFillRule><code>nonzero</code></dfn>" value
  indicates the non-zero winding rule, wherein a point is considered to be outside a shape if the number of times a half-infinite straight
  line drawn from that point crosses the shape's path going in one direction is equal to the
  number of times it crosses the path going in the other direction.
  </p>


  <p>The "<dfn value for=CanvasFillRule"><code>evenodd</code></dfn>" value indicates
  the even-odd rule, wherein a point is considered to be outside a shape if the number of times a half-infinite straight
  line drawn from that point crosses the shape's path is even.
  </p>

  <p>If a point is not outside a shape, it is inside the shape.</p>


  <h2 id="implementation-notes" title="notes on canvas 2D implementation">Implementation notes</h2>

  <!-- NON-NORMATIVE SECTION -->

  <p>Although the way the specification is written it might sound like an implementation needs to
  track up to four bitmaps per canvas or rendering context &mdash; one <span>scratch bitmap</span>,
  one <span>output bitmap</span> for the rendering context, one bitmap for the <code>canvas</code>,
  and one bitmap for the actually currently rendered image &mdash; user agents can in fact generally
  optimise this to only one or two.</p>

  <p>The <span>scratch bitmap</span>, when it isn't the same bitmap as the <span>output
  bitmap</span>, is only directly observable if it is read, and therefore implementations can,
  instead of updating this bitmap, merely remember the sequence of drawing operations that have been
  applied to it until such time as the bitmap's actual data is needed (for example because of a call
  to <a link-for=CanvasRenderingContext2D link-type=method>commit()</a>, <code
  data-x="dom-context-2d-drawImage">drawImage()</code>, or the <code data-x="dom-createImageBitmap">createImageBitmap()</code>
  factory method). In many cases, this will be more memory efficient.</p>

  <p>The bitmap of a <code>canvas</code> element is the one bitmap that's pretty much always going
  to be needed in practice. The <span>output bitmap</span> of a rendering context, when it has one,
  is always just an alias to a <code>canvas</code> element's bitmap.</p>

  <p>Additional bitmaps are sometimes needed, e.g. to enable fast drawing when the canvas is being
  painted at a different size than its intrinsic size, or to enable double buffering so that the
  rendering commands from the <span>scratch bitmap</span> can be applied without the rendering being
  updated midway.</p>




  <h2 id="canvas-state" title="description of the canvas state">The canvas state</h2>

  <p>Each <a interface>CanvasRenderingContext2D</a> rendering context maintains a stack of drawing
  states. <dfn data-x="drawing state">Drawing states</dfn> consist of:</p>

  <ul class="brief">
   <li>The current <span data-x="dom-context-2d-transformation">transformation matrix</span>.</li>
   <li>The current <span>clipping region</span>.</li>
   <li>The current values of the following attributes: 
   <a link-for=CanvasRenderingContext2D link-type=attribute>strokeStyle</a>, 
   <a link-for=CanvasRenderingContext2D link-type=attribute>fillStyle</a>, <a
   link-for=CanvasRenderingContext2D link-type=attribute>globalAlpha</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>lineWidth</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>lineCap</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>lineJoin</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>miterLimit</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>lineDashOffset</a>, <a
   link-for=CanvasRenderingContext2D link-type=attribute>shadowOffsetX</a>, <a
   link-for=CanvasRenderingContext2D link-type=attribute>shadowOffsetY</a>, <a
   link-for=CanvasRenderingContext2D link-type=attribute>shadowBlur</a>, <a
   link-for=CanvasRenderingContext2D link-type=attribute>shadowColor</a>, <a
   link-for=CanvasRenderingContext2D link-type=attribute>globalCompositeOperation</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>font</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>textAlign</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>textBaseline</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>direction</a>, <a
   link-for=CanvasRenderingContext2D link-type=attribute>imageSmoothingEnabled</a>.</li>
   <li>The current <a link-for=CanvasDrawingStyles link-type=attribute>dash list</a>.</li>
  </ul>

  <p class="note">The <span>current default path</span> and the rendering context's bitmaps are not
  part of the drawing state. The <span>current default path</span> is persistent, and can only be
  reset using the <code data-x="dom-context-2d-beginPath">beginPath()</code> method. The bitmaps
  depend on whether and how the rendering context is bound to a <code>canvas</code> element.</p>

  <dl class="domintro">

   <dt><var>context</var>.<a link-for=CanvasRenderingContext2D link-type=method><code>save()</code></a></dt>

   <dd>

    <p>Pushes the current state onto the stack.</p>

   </dd>

   <dt><var>context</var>.<a link-for=CanvasRenderingContext2D link-type=method><code>restore()</code></a></dt>

   <dd>

    <p>Pops the top state on the stack, restoring the context to that state.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn dfn-for=CanvasRenderingContext2D dfn-type=method><code>save()</code></dfn> method must push a copy of the
  current drawing state onto the drawing state stack.</p>

  <p>The <dfn dfn-for=CanvasRenderingContext2D dfn-type=method><code>restore()</code></dfn> method must pop the top
  entry in the drawing state stack, and reset the drawing state it describes. If there is no saved
  state, the method must do nothing.</p>

  <p>When the user agent is to <dfn>reset the rendering context to its default state</dfn>, it must
  clear the drawing state stack and everything that <span>drawing state</span> consists of to
  initial values.</p>


  </div>


  <h2 id="drawingstyle-id" title="describe elements of the drawing style object"><code>DrawingStyle</code> objects</h2>

  <p>All the line styles (line width, caps, joins, and dash patterns) and text styles (fonts)
  described in the next two sections apply to <a interface>CanvasRenderingContext2D</a> objects and to
  <a interface><code>DrawingStyle</code></a> objects. This section defines the constructor used to obtain a
  <a interface><code>DrawingStyle</code></a> object. This object is then used by methods on <code>Path2D</code>
  objects to control how text and paths are rasterised and stroked.</p>

  <dl class="domintro">

   <dt><var>styles</var> = new <a interface><code>DrawingStyle</code></a>( [ <var>element</var> ] )</dt>

   <dd>

    <p>Creates a new <a interface><code>DrawingStyle</code></a> object, optionally using a specific element for
    resolving relative keywords and sizes in font specifications.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Each <a interface><code>DrawingStyle</code></a> object can have a <dfn>styles scope object</dfn>.</p>

  <p>The <dfn dfn-for=DrawingStyle dfn-type=constructor>DrawingStyle()</dfn> constructor, when invoked,
  must return a newly created <a interface><code>DrawingStyle</code></a> object. If the constructor was passed an
  argument, then the <a interface><code>DrawingStyle</code></a> object's <span>styles scope object</span> is that
  element. Otherwise, if the <span>JavaScript global environment</span> is a <span>document
  environment</span>, the object's <span>styles scope object</span> is the <code>Document</code>
  object of the <span>active document</span> of the <span>browsing context</span> of the
  <code>Window</code> object on which the interface object of the invoked constructor is found.
  Otherwise, the <span>JavaScript global environment</span> is a <span>worker environment</span>,
  and the <span>styles scope object</span> is the worker.</p>

  </div>

<h2 id="line-styles" title="description of canvas line styles">Line styles</h2>

  <dl class="domintro">

   <dt><var>context</var>.<a link-for=CanvasDrawingStyles attribute><code>lineWidth</code></a> [ = <var>value</var> ]</dt>
   <dt><var>styles</var>.<a link-for=CanvasDrawingStyles attribute><code>lineWidth</code></a> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the current line width.</p>

    <p>Can be set, to change the line width. Values that are not finite values greater than zero are
    ignored.</p>

   </dd>

   <dt><var>context</var>.<a link-for=CanvasDrawingStyles attribute><code>lineCap</code></a> [ = <var>value</var> ]</dt>
   <dt><var>styles</var>.<a link-for=CanvasDrawingStyles attribute><code>lineCap</code></a> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the current line cap style.</p>

    <p>Can be set, to change the line cap style.</p>

    <p>The possible line cap styles are <code>butt</code>, <code>round</code>, and
    <code>square</code>. Other values are ignored.</p>

   </dd>

   <dt><var>context</var>.<a link-for=CanvasDrawingStyles attribute><code>lineJoin</code></a> [ = <var>value</var> ]</dt>
   <dt><var>styles</var>.<a link-for=CanvasDrawingStyles attribute><code>lineJoin</code></a> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the current line join style.</p>

    <p>Can be set, to change the line join style.</p>

    <p>The possible line join styles are <code>bevel</code>, <code>round</code>, and
    <code>miter</code>. Other values are ignored.</p>

   </dd>

   <dt><var>context</var>.<a link-for=CanvasDrawingStyles attribute><code>miterLimit</code></a> [ = <var>value</var> ]</dt>
   <dt><var>styles</var>.<a link-for=CanvasDrawingStyles attribute><code>miterLimit</code></a> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the current miter limit ratio.</p>

    <p>Can be set, to change the miter limit ratio. Values that are not finite values greater than
    zero are ignored.</p>

   </dd>


   <dt><var>context</var>.<a link-for=CanvasDrawingStyles method><code>setLineDash(<var>segments</var>)</code></a></dt>
   <dt><var>styles</var>.<a link-for=CanvasDrawingStyles method><code>setLineDash(<var>segments</var>)</code></a></dt>

   <dd>

    <p>Sets the current line dash pattern (as used when stroking). The argument is a list of
    distances for which to alternately have the line on and the line off.</p>

   </dd>


   <dt><var>segments</var> = <var>context</var>.<a link-for=CanvasDrawingStyles method><code>getLineDash()</code></a></dt>
   <dt><var>segments</var> = <var>styles</var>.<a link-for=CanvasDrawingStyles method><code>getLineDash()</code></a></dt>

   <dd>

    <p>Returns a copy of the current line dash pattern. The array returned will always have an even
    number of entries (i.e. the pattern is normalized).</p>

   </dd>


   <dt><var>context</var>.<a link-for=CanvasDrawingStyles attribute><code>lineDashOffset</code></a></dt>
   <dt><var>styles</var>.<a link-for=CanvasDrawingStyles attribute><code>lineDashOffset</code></a></dt>

   <dd>

    <p>Returns the phase offset (in the same units as the line dash pattern).</p>

    <p>Can be set, to change the phase offset. Values that are not finite values are ignored.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Objects that implement the <a interface>CanvasDrawingStyles</a> interface have attributes and
  methods (defined in this section) that control how lines are treated by the object.</p>

  <p>The <dfn dfn-for=CanvasDrawingStyles dfn-type=attribute><code>lineWidth</code></dfn> attribute gives the
  width of lines, in coordinate space units. On getting, it must return the current value. On
  setting, zero, negative, infinite, and NaN values must be ignored, leaving the value unchanged;
  other values must change the current value to the new value.</p>

  <p>When the object implementing the <a interface><code>CanvasDrawingStyles</code></a> interface is created, the
  <a link-for=CanvasDrawingStyles attribute><code>lineWidth</code></a> attribute must initially have the value
  <code>1.0</code>.</p>

  <hr>

  <p>The <dfn dfn-for=CanvasDrawingStyles dfn-type=attribute><code>lineCap</code></dfn> attribute defines the type
  of endings that UAs will place on the end of lines. The three valid values are <code>butt</code>,
  <code>round</code>, and <code>square</code>.</p>

  <p>On getting, it must return the current value. On setting, if the new value is one of the
  literal strings <code>butt</code>, <code>round</code>, and <code>square</code>, then the current
  value must be changed to the new value; other values must ignored, leaving the value
  unchanged.</p>

  <p>When the object implementing the <a interface><code>CanvasDrawingStyles</code></a> interface is created, the
  <a link-for=CanvasDrawingStyles attribute><code>lineCap</code></a> attribute must initially have the value
  <code>butt</code>.</p>

  <hr>

  <p>The <dfn dfn-for=CanvasDrawingStyles dfn-type=attribute><code>lineJoin</code></dfn> attribute defines the type
  of corners that UAs will place where two lines meet. The three valid values are
  <code>bevel</code>, <code>round</code>, and <code>miter</code>.</p>

  <p>On getting, it must return the current value. On setting, if the new value is one of the
  literal strings <code>bevel</code>, <code>round</code>, and <code>miter</code>, then the current
  value must be changed to the new value; other values must be ignored, leaving the value
  unchanged.</p>

  <p>When the object implementing the <a interface><code>CanvasDrawingStyles</code></a> interface is created, the
  <a link-for=CanvasDrawingStyles attribute><code>lineJoin</code></a> attribute must initially have the value
  <code>miter</code>.</p>

  <hr>

  <p>When the <a link-for=CanvasDrawingStyles attribute><code>lineJoin</code></a> attribute has the value
  <code>miter</code>, strokes use the miter limit ratio to decide how to render joins. The miter
  limit ratio can be explicitly set using the <dfn dfn-for=CanvasDrawingStyles dfn-type=attribute>
  <code>miterLimit</code></dfn> attribute. On getting, it must
  return the current value. On setting, zero, negative, infinite, and NaN values must be ignored,
  leaving the value unchanged; other values must change the current value to the new value.</p>
  <!-- values less than 1.0 are equivalent to 1.0, since it's compared
       against a ratio that can't be less than 1.0 -->

  <p>When the object implementing the <a interface><code>CanvasDrawingStyles</code></a> interface is created, the
  <a link-for=CanvasDrawingStyles attribute><code>miterLimit</code></a> attribute must initially have the value
  <code>10.0</code>.</p>

  <hr>

  <p>Each <a interface><code>CanvasDrawingStyles</code></a> object has a <dfn dfn-for=CanvasDrawingStyles dfn-type=attribute>dash list</dfn>, which is either empty
  or consists of an even number of non-negative numbers. Initially, the <a link-for=CanvasDrawingStyles link-type=attribute>dash list</a> must
  be empty.</p>

  <p>When the <dfn dfn-for=CanvasDrawingStyles dfn-type=method><code>setLineDash()</code></dfn> method is
  invoked, it must run the following steps:</p>

  <ol>

   <li><p>Let <var>a</var> be the argument.</p></li>

   <li><p>If any value in <var>a</var> is not finite (e.g. an Infinity or a NaN value), or
   if any value is negative (less than zero), then abort these steps (without throwing an exception;
   user agents could show a message on a developer console, though, as that would be helpful for
   debugging).</p></li>

   <li><p>If the number of elements in <var>a</var> is odd, then let <var>a</var>
   be the concatentation of two copies of <var>a</var>.</p></li>

   <li><p>Let the object's <a link-for=CanvasDrawingStyles link-type=attribute>dash list</a> be <var>a</var>.</p></li>

  </ol>

  <p>When the <dfn dfn-for=CanvasDrawingStyles dfn-type=method><code>getLineDash()</code></dfn> method is
  invoked, it must return a sequence whose values are the values of the object's <span>dash
  list</span>, in the same order.</p>

  <p>It is sometimes useful to change the "phase" of the dash pattern, e.g. to achieve a "marching
  ants" effect. The phase can be set using the <dfn
   dfn-for=CanvasDrawingStyles dfn-type=attribute><code>lineDashOffset</code></dfn> attribute. On getting, it
  must return the current value. On setting, infinite and NaN values must be ignored, leaving the
  value unchanged; other values must change the current value to the new value.</p>

  <p>When the object implementing the <a interface><code>CanvasDrawingStyles</code></a> interface is created, the
  <a link-for=CanvasDrawingStyles attribute><code>lineDashOffset</code></a> attribute must initially have
  the value <code>0.0</code>.</p>

  <hr>

  <p>When a user agent is to <dfn>trace a path</dfn>, <!-- <dfn>trace a path</dfn> -->
  given an object <var>style</var> that implements the <a interface><code>CanvasDrawingStyles</code></a>
  interface, it must run the following algorithm. This algorithm returns a new <span
  data-x="concept-path">path</span>.</p>

  <ol>

   <li><p>Let <var>path</var> be a copy of the path being traced.</p></li>

   <!-- PATH SANITIZATION -->

   <li><p>Prune all zero-length <span>line segments</span> from <var>path</var>.</p></li>

   <li><p>Remove from <var>path</var> any subpaths containing no lines (i.e. subpaths with
   just one point).</p></li>

   <li><p>Replace each point in each subpath of <var>path</var> other than the first point
   and the last point of each subpath by a <b>join</b> that joins the line leading to that point to
   the line leading out of that point, such that the subpaths all consist of two points (a starting
   point with a line leading out of it, and an ending point with a line leading into it), one or
   more lines (connecting the points and the joins), and zero or more joins (each connecting one
   line to another), connected together such that each subpath is a series of one or more lines with
   a join between each one and a point on each end.</p></li>

   <li><p>Add a straight closing line to each closed subpath in <var>path</var> connecting
   the last point and the first point of that subpath; change the last point to a join (from the
   previously last line to the newly added closing line), and change the first point to a join (from
   the newly added closing line to the first line).</p>

   <li><p>If the <var>styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>dash list</a> is empty, jump to the step
   labeled <b>convert</b>.</p></li>

   <!-- DASHING -->

   <li><p>Let <var>pattern width</var> be the concatenation of all the entries of the <var
   data-x="">styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>dash list</a>, in coordinate space units.</p>

   <li><p>For each subpath <var>subpath</var> in <var>path</var>, run the
   following substeps. These substeps mutate the subpaths in <var>path</var> <b>in
   vivo</b>.</p>

    <ol>

     <li><p>Let <var>subpath width</var> be the length of all the lines of <var
     data-x="">subpath</var>, in coordinate space units.</p>

     <li><p>Let <var>offset</var> be the value of the <var>styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>lineDashOffset</a>, 
     in coordinate space units.</p></li>

     <li>

      <p>While <var>offset</var> is greater than <var>pattern width</var>,
      decrement it by <var>pattern width</var>.</p>

      <p>While <var>offset</var> is less than zero, increment it by <var>pattern
      width</var>.</p>

     </li>

     <li><p>Define <var>L</var> to be a linear coordinate line defined along all lines in
     <var>subpath</var>, such that the start of the first line in the subpath is defined
     as coordinate 0, and the end of the last line in the subpath is defined as coordinate <var
     data-x="">subpath width</var>.</p></li>

     <li><p>Let <var>position</var> be zero minus <var>offset</var>.</p></li>

     <li><p>Let <var>index</var> be 0.</p></li>

     <li><p>Let <var>current state</var> be <b>off</b> (the other states being <b>on</b>
     and <b>zero-on</b>).</p></li>

     <li><p><b>Dash on</b>: Let <var>segment length</var> be
     the value of the <var>styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>dash
     list</a>'s <var>index</var>th entry.</p></li>

     <li><p>Increment <var>position</var> by <var>segment length</var>.</p></li>

     <li><p>If <var>position</var> is greater than <var>subpath width</var>, then
     end these substeps for this subpath and start them again for the next subpath; if there are no
     more subpaths, then jump to the step labeled <b>convert</b> instead.</p></li>

     <li><p>If <var>segment length</var> is non-zero, let <var
     data-x="">current state</var> be <b>on</b>.</p></li>

     <li><p>Increment <var>index</var> by one.</p></li>

     <li><p><b>Dash off<!-- labeled for consistency only --></b>: Let <var>segment
     length</var> be the value of the <var>styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>dash list</a>'s <var
     data-x="">index</var>th entry.</p></li>

     <li><p>Let <var>start</var> be the offset <var>position</var> on <var
     data-x="">L</var>.</p></li>

     <li><p>Increment <var>position</var> by <var>segment length</var>.</p></li>

     <li><p>If <var>position</var> is less than zero, then jump to the step labeled
     <b>post-cut</b>.</p></li> <!-- start and end both before zero -->

     <li><p>If <var>start</var> is less than zero, then let <var>start</var> be
     zero.</p></li> <!-- end will be (at or) after zero -->

     <li><p>If <var>position</var> is greater than <var>subpath width</var>, then
     let <var>end</var> be the offset <var>subpath width</var> on <var
     data-x="">L</var>. Otherwise, let <var>end</var> be the offset <var
     data-x="">position</var> on <var>L</var>.</p></li>

     <li>

      <p>Jump to the first appropriate step:</p>

      <dl class="switch">

       <dt>If <var>segment length</var> is zero and <var>current state</var> is <b>off</b></dt>

       <dd>

        <p>Do nothing, just continue to the next step.</p>

       </dd>


       <dt>If <var>current state</var> is <b>off</b></dt>

       <dd>

        <p>Cut the line on which <var>end</var> finds itself short at <var
        data-x="">end</var> and place a point there, cutting the subpath that it was in in two;
        remove all line segments, joins, points, and subpaths that are between <var
        data-x="">start</var> and <var>end</var>; and finally place a single point at <var
        data-x="">start</var> with no lines connecting to it.</p>

        <p>The point has a <b>directionality</b> for the purposes of drawing line caps (see below).
        The directionality is the direction that the original line had at that point (i.e. when <var
        data-x="">L</var> was defined above).</p>

       </dd>


       <dt>Otherwise</dt>

       <dd>

        <p>Cut the line on which <var>start</var> finds itself into two at <var
        data-x="">start</var> and place a point there, cutting the subpath that it was in in two, and
        similarly cut the line on which <var>end</var> finds itself short at <var
        data-x="">end</var> and place a point there, cutting the subpath that <em>it</em> was in in
        two, and then remove all line segments, joins, points, and subpaths that are between <var
        data-x="">start</var> and <var>end</var>.</p>

        <p>If <var>start</var> and <var>end</var> are the same point, then this
        results in just the line being cut in two and two points being inserted there, with nothing
        being removed, unless a join also happens to be at that point, in which case the join must
        be removed.</p>

       </dd>

      </dl>

     </li>

     <li><p><b>Post-cut</b>: If <var>position</var> is greater than <var
     data-x="">subpath width</var>, then jump to the step labeled <b>convert</b>.</p></li>

     <li><p>If <var>segment length</var> is greater than zero, let <var
     data-x="">positioned-at-on-dash</var> be false.</p></li>

     <li><p>Increment <var>index</var> by one. If it is equal to the number of entries in
     the <var>styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>dash list</a>, then let <var>index</var> be
     0.</p></li>

     <li><p>Return to the step labeled <b>dash on</b>.</p></li>

    </ol>

   </li>
    <!-- STROKING -->

   <li>

    <p><b>Convert</b>: This is the step that converts the path to a new path that represents its
    stroke.</p>

    <p>Create a new <span data-x="concept-path">path</span> that describes the edge of the areas
    that would be covered if a straight line of length equal to the <var>styles</var>
    <a link-for=CanvasDrawingStyles link-type=attribute>lineWidth</a> was swept along each subpath in <var
    data-x="">path</var> while being kept at an angle such that the line is orthogonal to the path
    being swept, replacing each point with the end cap necessary to satisfy the <var
    data-x="">styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>lineCap</a> attribute as
    described previously and elaborated below, and replacing each join with the join necessary to
    satisfy the <var>styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>lineJoin</a> type, as defined below.</p>

    <p><strong>Caps</strong>: Each point has a flat edge perpendicular to the direction of the line
    coming out of it. This is them augmented according to the value of the <var
    data-x="">styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>lineCap</a>. The
    <code>butt</code> value means that no additional line cap is added. The <code>round</code> value
    means that a semi-circle with the diameter equal to the <var>styles</var> <a link-for=CanvasDrawingStyles 
    link-type=attribute>lineWidth</a> width must additionally be placed on to the
    line coming out of each point. The <code>square</code> value means that a rectangle with the
    length of the <var>styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>lineWidth</a> 
    width and the width of half the <var data-x="">styles</var> <a link-for=CanvasDrawingStyles 
    link-type=attribute>lineWidth</a> width, placed
    flat against the edge perpendicular to the direction of the line coming out of the point, must
    be added at each point.</p>

    <p>Points with no lines coming out of them must have two caps placed back-to-back as if it was
    really two points connected to each other by an infinitesimally short straight line in the
    direction of the point's <b>directionality</b> (as defined above).</p>

    <p><strong>Joins</strong>: In addition to the point where a join occurs, two additional points
    are relevant to each join, one for each line: the two corners found half the line width away
    from the join point, one perpendicular to each line, each on the side furthest from the other
    line.</p>

    <p>A triangle connecting these two opposite corners with a straight line, with the third point
    of the triangle being the join point, must be added at all joins. The <a 
    link-for=CanvasDrawingStyles link-type=attribute>lineJoin</a> attribute controls whether anything else is
    rendered. The three aforementioned values have the following meanings:</p>

    <p>The <code>bevel</code> value means that this is all that is rendered at joins.</p>

    <p>The <code>round</code> value means that an arc connecting the two aforementioned corners of
    the join, abutting (and not overlapping) the aforementioned triangle, with the diameter equal to
    the line width and the origin at the point of the join, must be added at joins.</p>

    <p>The <code>miter</code> value means that a second triangle must (if it can given the miter
    length) be added at the join, with one line being the line between the two aforementioned
    corners, abutting the first triangle, and the other two being continuations of the outside edges
    of the two joining lines, as long as required to intersect without going over the miter
    length.</p>

    <p>The miter length is the distance from the point where the join occurs to the intersection of
    the line edges on the outside of the join. The miter limit ratio is the maximum allowed ratio of
    the miter length to half the line width. If the miter length would cause the miter limit ratio
    (as set by the <var>style</var> <a link-for=CanvasDrawingStyles link-type=attribute>miterLimit</a> 
    attribute) to be exceeded, this second triangle must not be added.</p> <!-- the actual ratio can't possibly be less than 1.0 -->


    <p>The subpaths in the newly created path must be oriented such that for any point, the number
    of times a half-infinite straight line drawn from that point crosses a subpath is even if and
    only if the number of times a half-infinite straight line drawn from that same point crosses a
    subpath going in one direction is equal to the number of times it crosses a subpath going in the
    other direction.</p>

   </li>

   <li><p>Return the newly created path.</p></li>

  </ol>

  </div>

  <h2 id="text-styles" title="description of canvas text styles">Text styles</h2>

  <dl class="domintro">

   <dt><var>context</var>.<a link-for=CanvasDrawingStyles attribute>font</a> [ = <var>value</var> ]</dt>
   <dt><var>styles</var>.<a link-for=CanvasDrawingStyles attribute>font</a> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the current font settings.</p>

    <p>Can be set, to change the font. The syntax is the same as for the CSS 'font' property; values
    that cannot be parsed as CSS font values are ignored.</p>

    <p>Relative keywords and lengths are computed relative to the font of the <code>canvas</code>
    element.</p>

   </dd>

   <dt><var>context</var>.<a link-for=CanvasDrawingStyles attribute>textAlign</a> [ = <var>value</var> ]</dt>
   <dt><var>styles</var>.<a link-for=CanvasDrawingStyles attribute>textAlign</a> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the current text alignment settings.</p>

    <p>Can be set, to change the alignment. The possible values are and their meanings are given
    below. Other values are ignored. The default is <a link-for=textAlign link-type=value><code>start</code></a>.</p>

   </dd>

   <dt><var>context</var>.<a link-for=CanvasDrawingStyles attribute>textBaseline</a> [ = <var>value</var> ]</dt>
   <dt><var>styles</var>.<a link-for=CanvasDrawingStyles attribute>textBaseline</a> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the current baseline alignment settings.</p>

    <p>Can be set, to change the baseline alignment. The possible values and their meanings are
    given below. Other values are ignored. The default is <a link-for=textBaseline link-type=value><code>alphabetic</code></a>.</p>

   </dd>

   <dt><var>context</var>.<a link-for=CanvasDrawingStyles attribute>direction</a> [ = <var>value</var> ]</dt>
   <dt><var>styles</var>.<a link-for=CanvasDrawingStyles attribute>direction</a> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the current directionality.</p>

    <p>Can be set, to change the directionality. The possible values and their meanings are given
    below. Other values are ignored. The default is <code>inherit</code>.</p>

   </dd>

  </dl>
 
  
  <div class="impl">

  <p>Objects that implement the <a interface>CanvasDrawingStyles</a> interface have attributes (defined
  in this section) that control how text is laid out (rasterised or outlined) by the object. Such
  objects can also have a <dfn>font style source object</dfn>. For
  <a interface>CanvasRenderingContext2D</a> objects whose <span>context bitmap mode</span> is <span>
  fixed</span>, this is their <code>canvas</code> element; for other
  <a interface>CanvasRenderingContext2D</a> objects, if the <span>JavaScript global environment</span>
  is a <span>document environment</span>, the object's <span>font style source object</span> is the
  <code>Document</code> object of the <span>active document</span> of the <span>browsing
  context</span> of the <code>Window</code> object on which the interface object of the
  <a interface>CanvasRenderingContext2D</a> object is found; otherwise the <span>JavaScript global
  environment</span> is a <span>worker environment</span> and the <span>font style source
  object</span> is the worker. For <code>DrawingStyle</code> objects, it's the <span>styles scope
  object</span>.</p>

  <p>The <dfn dfn-for=CanvasDrawingStyles dfn-type=attribute><code>font</code></dfn> IDL attribute, on setting, must
  be parsed the same way as the 'font' property of CSS (but without supporting property-independent
  style sheet syntax like <code class="property">inherit</code>), and the resulting font must be assigned to the context, with
  the 'line-height' component forced to <code class="property">normal</code>, 
  with the 'font-size' component converted to CSS
  pixels, and with system fonts being computed to explicit values. If the new value is syntactically
  incorrect (including using property-independent style sheet syntax like <code class="property">inherit</code> or <code class="property">initial</code>),
  then it must be ignored, without assigning a new font value. <a href="#refsCSS">[CSS]</a></p>

  <p>Font family names must be interpreted in the context of the <span>font style source
  object</span> when the font is to be used; any fonts embedded using <code>@font-face</code> 
  or loaded using the <code>FontLoader</code> that are visible to the
  <span>font style source object</span> must therefore be available once they are loaded. If a font
  is used before it is fully loaded, or if the <span>font style source object</span> does not have
  that font in scope at the time the font is to be used, then it must be treated as if it was an
  unknown font, falling back to another as described by the relevant CSS specifications. <a
  href="#refsCSSFONTS">[CSSFONTS]</a> <a href="#refsCSSFONTLOAD">[CSSFONTLOAD]</a></p>

  <p>On getting, the <code data-x="dom-context-2d-font">font</code> attribute must return the <span
  data-x="serializing a CSS value">serialised form</span> of the current font of the context (with
  no 'line-height' component). <a href="#refsCSSOM">[CSSOM]</a></p>

  <div class="example">

   <p>For example, after the following statement:</p>

   <pre>context.font = 'italic 400 12px/2 Unknown Font, sans-serif';</pre>

   <p>...the expression <code data-x="">context.font</code> would evaluate to the string "<code
   data-x="">italic&nbsp;12px&nbsp;&quot;Unknown&nbsp;Font&quot;,&nbsp;sans-serif</code>". The "400"
   font-weight doesn't appear because that is the default value. The line-height doesn't appear
   because it is forced to "normal", the default value.</p>

  </div>

  <p>When the object implementing the <a interface>CanvasDrawingStyles</a> interface is created, the
  font of the context must be set to 10px sans-serif. When the 'font-size' component is set to
  lengths using percentages, <code class="property">em</code> or <code class="property">ex</code> units, 
  or the <code class="property">larger</code> or <code class="property">smaller</code> keywords, these must
  be interpreted relative to the computed value of the 'font-size' property of the <span>font style
  source object</span> at the time that the attribute is set, if it is an element. When the
  <code class="property">font-weight</code> component is set to the relative values 
  <code class="property">bolder</code> and <code class="property">lighter</code>, these must be
  interpreted relative to the computed value of the <code class="property">font-weight</code> property of the <span>font style
  source object</span> at the time that the attribute is set, if it is an element. If the computed
  values are undefined for a particular case (e.g. because the <span>font style source object</span>
  is not an element or is not <span>being rendered</span>), then the relative keywords must be
  interpreted relative to the normal-weight 10px sans-serif default.</p>

  <p>The <dfn dfn-for=CanvasDrawingStyles dfn-type=attribute><code>textAlign</code></dfn> IDL attribute, on
  getting, must return the current value. On setting, if the value is one of <a link-for=textAlign link-type=value>start</a>, 
  <a link-for=textAlign link-type=value>end</a>, <a link-for=textAlign link-type=value>left</a>, 
  <a link-for=textAlign link-type=value>right</a>, or <a link-for=textAlign link-type=value>center</a>, then the value must be changed to the new
  value. Otherwise, the new value must be ignored. When the object implementing the
  <a interface>CanvasDrawingStyles</a> interface is created, the <code>textAlign</code> attribute 
  must initially have the value <a dfn-for=direction dfn-type=value><code>start</code></a>.</p>

  <p>The <dfn dfn-for=CanvasDrawingStyles dfn-type=attribute><code>textBaseline</code></dfn> IDL attribute, on
  getting, must return the current value. On setting, if the value is one of <a link-for=textBaseline link-type=value>top</a>, 
  <a link-for=textBaseline link-type=value>hanging</a>, <a link-for=textBaseline link-type=value>middle</a>, 
  <a link-for=textBaseline link-type=value>alphabetic</a>, <a link-for=textBaseline link-type=value>ideographic</a>, 
  or <a link-for=textBaseline link-type=value>bottom</a>, then the value must be changed to the
  new value. Otherwise, the new value must be ignored. When the object implementing the
  <a interface>CanvasDrawingStyles</a> interface is created, the 
  <a link-for=CanvasDrawingStyles link-type=attribute><code>textBaseline</code></a> attribute must initially have the value
  <a link-for=textBaseline link-type=value><code>alphabetic</code></a>.</p>

  <p>The <dfn dfn-for=CanvasDrawingStyles dfn-type=attribute><code>direction</code></dfn> IDL attribute, on
  getting, must return the current value. On setting, if the value is one of <a link-for=direction link-type=value>ltr</a>, 
  <a link-for=direction link-type=value>rtl</a>, or <a link-for=direction link-type=value>inherit</a>, 
  then the value must be changed to the new value. Otherwise, the new value must be ignored. When the object implementing the
  <a interface>CanvasDrawingStyles</a> interface is created, the <a link-for=CanvasDrawingStyles link-type=attribute><code>direction</code></a> attribute must 
  initially have the value <a link-for=direction link-type=value>inherit</a link-for=direction link-type=value>.</p>

  <p>The <a link-for=CanvasDrawingStyles link-type=attribute><code>textAlign</code></a> attribute's allowed keywords are
  as follows:</p>

  <dl>

   <dt><dfn dfn-for=textAlign dfn-type=value><code>start</code></dfn>
   <dd><p>Align to the start edge of the text (left side in left-to-right text, right side in
   right-to-left text).</p></dd>

   <dt><dfn dfn-for=textAlign dfn-type=value><code>end</code></dfn>
   <dd><p>Align to the end edge of the text (right side in left-to-right text, left side in
   right-to-left text).</p></dd>

   <dt><dfn dfn-for=textAlign dfn-type=value><code>left</code></dfn>
   <dd><p>Align to the left.</p></dd>

   <dt><dfn dfn-for=textAlign dfn-type=value><code>right</code></dfn>
   <dd><p>Align to the right.</p></dd>

   <dt><dfn dfn-for=textAlign dfn-type=value><code>center</code></dfn>
   <dd><p>Align to the center.</p></dd>

  </dl>

  <p>The <a link-for=CanvasDrawingStyles link-type=attribute>textBaseline</a>
  attribute's allowed keywords correspond to alignment points in the
  font:</p>

  <p><img src="images/baselines.png" width="738" height="300" alt="The top of the em square is roughly at the top of the glyphs in a font, the hanging baseline is where some glyphs like &#x0906; are anchored, the middle is half-way between the top of the em square and the bottom of the em square, the 
  <a link-for=textBaseline link-type=value><code>alphabetic</code></a> baseline is where characters like &#x00C1;, &#x00FF;, &#x0066;, and &#x03A9; are anchored, the ideographic baseline is where glyphs like &#x79C1; and &#x9054; are anchored, and the bottom of the em square is roughly at the bottom of the glyphs in a font. The top and bottom of the bounding box can be far from these baselines, due to glyphs extending far outside the em square."></p>

  <p>The keywords map to these alignment points as follows:</p>

  <dl>

   <dt><dfn dfn-for=textBaseline dfn-type=value><code>top</code></dfn>
   <dd>The top of the em square</dd>

   <dt><dfn dfn-for=textBaseline dfn-type=value><code>hanging</code></dfn>
   <dd>The hanging baseline</dd>

   <dt><dfn dfn-for=textBaseline dfn-type=value><code>middle</code></dfn>
   <dd>The middle of the em square</dd>

   <dt><dfn dfn-for=textBaseline dfn-type=value><code>alphabetic</code></dfn>
   <dd>The alphabetic baseline</dd>

   <dt><dfn dfn-for=textBaseline dfn-type=value><code>ideographic</code></dfn>
   <dd>The ideographic baseline</dd>

   <dt><dfn dfn-for=textBaseline dfn-type=value><code>bottom</code></dfn>
   <dd>The bottom of the em square</dd>

  </dl>

  <p>The <a link-for=CanvasDrawingStyles link-type=attribute>direction</a> attribute's allowed keywords are
  as follows:</p>

  <dl>

   <dt><dfn dfn-for=direction dfn-type=value><code>ltr</code></dfn>

   <dd><p>Treat input to the <span>text preparation algorithm</span> as left-to-right text.</p></dd>

   <dt><dfn dfn-for=direction dfn-type=value><code>rtl</code></dfn>

   <dd><p>Treat input to the <span>text preparation algorithm</span> as right-to-left text.</p></dd>

<!--
   <dt><dfn dfn-for=direction dfn-type=value><code>auto</code></dfn>

   <dd><p>Determine the direction from the input to the <span>text preparation algorithm</span>.</p></dd>
-->

   <dt><dfn dfn-for=direction dfn-type=value><code>inherit</code></dfn>

   <dd><p>Default to the directionality of the <code>canvas</code> element or <code>Document</code>
   as appropriate.</p></dd>

  </dl>

  <p>The <dfn>text preparation algorithm</dfn> is as follows. It takes as input a string <var
  data-x="">text</var>, a <a interface>CanvasDrawingStyles</a> object <var>target</var>, and an
  optional length <dfn><var>maxWidth</var></dfn>. It returns an array of glyph shapes, each positioned
  on a common coordinate space, a <var>physical alignment</var> whose value is one of
  <a link-for=textAlign link-type=value>left</a>, <a link-for=textAlign link-type=value>right</a>, 
  and <a link-for=textAlign link-type=value>center</a>, and an inline box. (Most callers of this
  algorithm ignore the <var>physical alignment</var> and the inline box.)</p>

  <ol>

   <li><p>If <var>maxWidth</var> was provided but is less than or equal to zero, return an
   empty array.</p></li>

   <li><p>Replace all the <span data-x="space character">space characters</span> in <var
   data-x="">text</var> with U+0020 SPACE characters.</p></li>

   <li><p>Let <var>font</var> be the current font of <var>target</var>, as given
   by that object's <code data-x="dom-context-2d-font">font</code> attribute.</p></li>

   <li>

    <p>Apply the appropriate step from the following list to determine the value of <var
    data-x="">direction</var>:</p>

    <dl class="switch">

     <dt>If the <var>target</var> object's <code
     data-x="dom-context-2d-direction">direction</code> attribute has the value 
     "<a a link-for=direction link-type=value><code>ltr</code></a>"</dt>
     <dd>Let <var>direction</var> be '<span>ltr</span>'.</dd>

     <dt>If the <var>target</var> object's <code>direction</code> attribute has the value 
     "<a link-for=direction link-type=value><code>rtl</code></a>"</dt>
     <dd>Let <var>direction</var> be '<a a link-for=direction link-type=value>rtl</a>'.</dd>

     <dt>If the <var>target</var> object's <span>font style source object</span> is an
     element</dt>

     <dd>Let <var>direction</var> be <span>the directionality</span> of the <var>target</var> object's <span>font style source object</span>.</dd>

     <dt>If the <var>target</var> object's <span>font style source object</span> is a
     <code>Document</code> and that <code>Document</code> has a root element child</dt>

     <dd>Let <var>direction</var> be <span>the directionality</span> of the <var
     data-x="">target</var> object's <span>font style source object</span>'s root element child.</dd>

     <dt>Otherwise</dt>

     <dd>Let <var>direction</var> be '<a link-for=direction link-type=value><code>ltr</code></a>'.</dd>

    </dl>

   </li>

   <li><p>Form a hypothetical infinitely-wide CSS line box containing a single inline box containing
   the text <var>text</var>, with all the properties at their initial values except the
   'font' property of the inline box set to <var>font</var>, the <code class="property">direction</code> property of
   the inline box set to <var>direction</var>, and the <code class="property">white-space</code> property set to <code class="property">pre</code>.
   <a href="#refsCSS">[CSS]</a></p></li>

   <!-- if you insert a step here, make sure to adjust the next step's final words -->

   <li><p>If <a><var>maxWidth</var></a> was provided and the hypothetical width of the inline box
   in the hypothetical line box is greater than <a><var>maxWidth</var></a> CSS pixels, then change
   <var>font</var> to have a more condensed font (if one is available or if a reasonably
   readable one can be synthesized by applying a horizontal scale factor to the font) or a smaller
   font, and return to the previous step.</p></li>

   <li>

    <p>The <var>anchor point</var> is a point on the inline box, and the <var>physical alignment</var>
    is one of the values <b>left</b>, <b>right</b>, and <b>center</b>. These variables 
    are determined by the <code>textAlign</code> and <a link-for=CanvasDrawingStyles link-type=attribute><code>textBaseline</code></a> values as follows:</p>

    <p>Horizontal position:</p>

    <dl>

     <dt>If <code data-x="dom-context-2d-textAlign">textAlign</code> is <code
     data-x="dom-concept-2d-textAlign-left">left</code></dt>

     <dt>If <code data-x="dom-context-2d-textAlign">textAlign</code> is <code
     data-x="dom-concept-2d-textAlign-start">start</code> and <var>direction</var> is
     <code class="property">ltr</code></dt>

     <dt>If <code data-x="dom-context-2d-textAlign">textAlign</code> is <code
     data-x="dom-concept-2d-textAlign-end">end</code> and <var>direction</var> is '<a a link-for=direction link-type=value>rtl</a>'</dt>

     <dd>Let the <var>anchor point</var>'s horizontal position be the left edge of the
     inline box, and let <var>physical alignment</var> be <b>left</b>.</dd>


     <dt>If <code data-x="dom-context-2d-textAlign">textAlign</code> is <code
     data-x="dom-concept-2d-textAlign-right">right</code></dt>

     <dt>If <code data-x="dom-context-2d-textAlign">textAlign</code> is <code
     data-x="dom-concept-2d-textAlign-end">end</code> and <var>direction</var> is '<a a link-for=direction link-type=value>ltr</a>'</dt>

     <dt>If <code data-x="dom-context-2d-textAlign">textAlign</code> is <code
     data-x="dom-concept-2d-textAlign-start">start</code> and <var>direction</var> is
     '<a a link-for=direction link-type=value>rtl</a>'</dt>

     <dd>Let the <var>anchor point</var>'s horizontal position be the right edge of the
     inline box, and let <var>physical alignment</var> be <b>right</b>.</dd>


     <dt>If <code data-x="dom-context-2d-textAlign">textAlign</code> is <code>center</code></dt>

     <dd>Let the <var>anchor point</var>'s horizontal position be half way between the left
     and right edges of the inline box, and let <var>physical alignment</var> be <b>center</b>.</dd>

    </dl>

    <p>Vertical position:</p>

    <dl>

     <dt>If <a link-for=CanvasDrawingStyles link-type=attribute><code>textBaseline</code></a> is <code
     data-x="dom-context-2d-textBaseline-top">top</code></dt>

     <dd>Let the <var>anchor point</var>'s vertical position be the top of the em box of
     the first available font of the inline box.</dd>


     <dt>If <a link-for=CanvasDrawingStyles link-type=attribute><code>textBaseline</code></a> is <code
     data-x="dom-context-2d-textBaseline-hanging">hanging</code></dt>

     <dd>Let the <var>anchor point</var>'s vertical position be the hanging baseline of the
     first available font of the inline box.</dd>


     <dt>If <a link-for=CanvasDrawingStyles link-type=attribute><code>textBaseline</code></a> is <code
     data-x="dom-context-2d-textBaseline-middle">middle</code></dt>

     <dd>Let the <var>anchor point</var>'s vertical position be half way between the bottom
     and the top of the em box of the first available font of the inline box.</dd>


     <dt>If <a link-for=CanvasDrawingStyles link-type=attribute><code>textBaseline</code></a> is 
     <a link-for=textBaseline link-type=value><code>alphabetic</code></a></dt>

     <dd>Let the <var>anchor point</var>'s vertical position be the alphabetic baseline of
     the first available font of the inline box.</dd>


     <dt>If <a link-for=CanvasDrawingStyles link-type=attribute><code>textBaseline</code></a> is <code
     data-x="dom-context-2d-textBaseline-ideographic">ideographic</code></dt>

     <dd>Let the <var>anchor point</var>'s vertical position be the ideographic baseline of
     the first available font of the inline box.</dd>


     <dt>If <a link-for=CanvasDrawingStyles link-type=attribute><code>textBaseline</code></a> is <code
     data-x="dom-context-2d-textBaseline-bottom">bottom</code></dt>

     <dd>Let the <var>anchor point</var>'s vertical position be the bottom of the em box of
     the first available font of the inline box.</dd>

    </dl>

   </li>

   <li>

    <p>Let <var>result</var> be an array constructed by iterating over each glyph in the
    inline box from left to right (if any), adding to the array, for each glyph, the shape of the
    glyph as it is in the inline box, positioned on a coordinate space using CSS pixels with its
    origin is at the <var>anchor point</var>.</p>

   </li>

   <li><p>Return <var>result</var>, <var>physical alignment</var>, and the inline
   box.</p></li>

  </ol>

  </div>