<h1>The 2D rendering context</h1>
<pre class='metadata'>
Shortname: Canvas 2D
Level: 2
Status: ED
ED: http://www.w3.org/html/wg/drafts/2dcontext/master/
TR: http://www.w3.org/TR/2dcontext2/
Previous Version: http://www.w3.org/TR/2013/WD-2dcontext2-20131029/
Group: HTML
Ignored Terms: float32array, float64array, indexsizeerror, DOMString, SVGMatrix
Link Defaults: css-color-3 (property) color
Editor: Rik Cabanier, Adobe Systems Inc., cabanier@adobe.com
Editor: Jatinder Mann, Microsoft Corporation, jmann@microsoft.com
Editor: Jay Munro, Microsoft Corporation, jaymunro@microsoft.com
Editor: Tom Wiltzius, Google Inc., wiltzius@google.com
Abstract: This specification defines the 2D Context for the HTML canvas element. The 2D Context provides objects, methods, and properties to draw and manipulate graphics on a canvas drawing surface.
</pre>

<script src=http://resources.whatwg.org/file-bug.js async></script>
<script src="../shared/MathJax/MathJax.js?config=MML_SVGorMML,local/local"></script>

<style type="text/css">
a[data-link-type=element]::before,span[data-link-type=element]::before {
  content: '<';
}
a[data-link-type=element]::after,span[data-link-type=element]::after {
  content: '>';
}
dl.domintro {
padding: 0.5em 1em;
border: none;
background: #E9FBE9;
border: 1px solid lightgray;
}
dl.domintro:before {
display: table;
margin: -1.5em -0.5em -0em auto;
width: auto;
content: 'This definition is non-normative. Implementation requirements are given below this definition.';
color: #606060;
border: 1px solid lightgray;
background: white;
padding: 0 0.25em;
font-size: .9em;
}
.h-entry {
  max-width: 65em;
}
</style>

<h2 id="2dcontext" title="IDL of the 2D graphics context">The 2D rendering context</h2>

<pre class="idl">
typedef (HTMLImageElement or
         HTMLVideoElement or
         HTMLCanvasElement or
         CanvasRenderingContext2D <!-- or
         ImageBitmap -->) <dfn>CanvasImageSource</dfn>;

enum CanvasFillRule { "nonzero", "evenodd" };

[Constructor(optional unsigned long width, unsigned long height), Exposed=Window,Worker]
interface CanvasRenderingContext2D {

  // back-reference to the canvas
  readonly attribute HTMLCanvasElement canvas;

  // canvas dimensions
  attribute unsigned long width;
  attribute unsigned long height;

  // for contexts that aren't directly <span data-x="concept-canvas-fixed">fixed</span> to a specific canvas
  void commit(); // push the image to the <span>output bitmap</span>

  // state
  void save(); // push state on state stack
  void restore(); // pop state stack and restore state

  // transformations (default transform is the identity matrix)
  attribute SVGMatrix currentTransform;
  void scale(unrestricted double x, unrestricted double y);
  void rotate(unrestricted double angle);
  void translate(unrestricted double x, unrestricted double y);
  void transform(unrestricted double a, unrestricted double b, unrestricted double c, 
                 unrestricted double d, unrestricted double e, unrestricted double f);
  void setTransform(unrestricted double a, unrestricted double b, unrestricted double c, 
                    unrestricted double d, unrestricted double e, unrestricted double f);
  void resetTransform();

  // compositing
  attribute unrestricted double globalAlpha; // (default 1.0)
  attribute DOMString globalCompositeOperation; // (default source-over)

  // image smoothing
  attribute boolean imageSmoothingEnabled; // (default true)

  // colors and styles (see also the CanvasDrawingStylesinterface)
  attribute (DOMString or CanvasGradient or CanvasPattern) strokeStyle; // (default black)
  attribute (DOMString or CanvasGradient or CanvasPattern) fillStyle; // (default black)
  CanvasGradient createLinearGradient(double x0, double y0, double x1, double y1);
  CanvasGradient createRadialGradient(double x0, double y0, double r0, double x1, 
                                      double y1, double r1);
  CanvasPattern createPattern(CanvasImageSource image, 
                              [TreatNullAs=EmptyString] DOMString repetition);

  // shadows
  attribute unrestricted double shadowOffsetX; 
  attribute unrestricted double shadowOffsetY; 
  attribute unrestricted double shadowBlur; // (default 0)
  attribute DOMString shadowColor; // (default transparent black)

  // rects
  void clearRect(unrestricted double x, unrestricted double y, unrestricted double w, 
                 unrestricted double h);
  void fillRect(unrestricted double x, unrestricted double y, unrestricted double w, 
                unrestricted double h);
  void strokeRect(unrestricted double x, unrestricted double y, unrestricted double w, 
                  unrestricted double h);

  // path API (see also CanvasPathMethods)
  void beginPath();
  void fill(optional CanvasFillRule fillRule = "nonzero");
  void <a title="fill-path2d">fill(Path2D path, optional CanvasFillRule fillRule = "nonzero")</a>;
  void stroke();
  void stroke(Path2D path);

  void drawFocusIfNeeded(Element element);
  void drawFocusIfNeeded(Path2D path, Element element);
 
  boolean drawCustomFocusRing(Element element);
  boolean drawCustomFocusRing(Path2D path, Element element);
  void scrollPathIntoView();
  void scrollPathIntoView(Path2D path);
  void clip(optional CanvasFillRule fillRule = "nonzero");
  void clip(Path2D path, optional CanvasFillRule fillRule = "nonzero");
  void resetClip();
  boolean isPointInPath(unrestricted double x, unrestricted double y, 
                        optional CanvasFillRule fillRule = "nonzero");
  boolean isPointInPath(Path2D path, unrestricted double x, unrestricted double y, 
                        optional CanvasFillRule fillRule = "nonzero");
  boolean isPointInStroke(unrestricted double x, unrestricted double y);
  boolean isPointInStroke(Path2D path, unrestricted double x, unrestricted double y);
 
  // text (see also the CanvasDrawingStyles< interface)
  void fillText(DOMString text, unrestricted double x, unrestricted double y, 
                optional unrestricted double maxWidth);
  void strokeText(DOMString text, unrestricted double x, unrestricted double y, 
                  optional unrestricted double maxWidth);
  // TextMetrics
  void measureText(DOMString text);
 
  // drawing images
  void drawImage(CanvasImageSource image, unrestricted double dx, unrestricted double dy);
  void drawImage(CanvasImageSource image, unrestricted double dx, unrestricted double dy, 
                 unrestricted double dw, unrestricted double dh);
  void drawImage(CanvasImageSource image, unrestricted double sx, unrestricted double sy, 
                 unrestricted double sw, unrestricted double sh, unrestricted double dx, 
                 unrestricted double dy, unrestricted double dw, unrestricted double dh);
 
  // hit regions
  void addHitRegion(optional HitRegionOptions options);
  void removeHitRegion(DOMString id);
  void clearHitRegions();
  
  // pixel manipulation
  ImageData createImageData(double sw, double sh);
  ImageData createImageData(ImageData imagedata);
  ImageData getImageData(double sx, double sy, double sw, double sh);
  void putImageData(ImageData imagedata, double dx, double dy);
  void putImageData(ImageData imagedata, double dx, double dy, double dirtyX, double dirtyY, 
                    double dirtyWidth, double dirtyHeight);
};

[NoInterfaceObject, Exposed=Window,Worker]
interface CanvasDrawingStyles {
  // line caps/joins
  attribute unrestricted double lineWidth; // (default 1)
  attribute DOMString lineCap; // "butt", "round", "square" (default "butt")
  attribute DOMString lineJoin; // "round", "bevel", "miter" (default "miter")
  attribute unrestricted double miterLimit; // (default 10)

  // dashed lines
  void setLineDash</span>(sequence&lt;unrestricted double> segments); // default empty
  sequence&lt;unrestricted double> getLineDash();
  attribute unrestricted double lineDashOffset;

  // text
  attribute DOMString font; // (default 10px sans-serif)
  attribute DOMString textAlign; // "start", "end", "left", "right", "center" (default: "start")
  attribute DOMString textBaseline; // "top", "hanging", "middle", "alphabetic", "ideographic", "bottom" (default: "alphabetic")
  attribute DOMString direction; // "ltr", "rtl", "inherit" (default: "inherit")
};

[NoInterfaceObject, Exposed=Window,Worker]
interface CanvasPathMethods {
  // shared path API methods
  void <span data-x="dom-context-2d-closePath">closePath</span>();
  void <span data-x="dom-context-2d-moveTo">moveTo</span>(unrestricted double x, unrestricted double y);
  void <span data-x="dom-context-2d-lineTo">lineTo</span>(unrestricted double x, unrestricted double y);
  void <span data-x="dom-context-2d-quadraticCurveTo">quadraticCurveTo</span>(unrestricted double cpx, unrestricted double cpy, unrestricted double x, unrestricted double y);
  void <span data-x="dom-context-2d-bezierCurveTo">bezierCurveTo</span>(unrestricted double cp1x, unrestricted double cp1y, unrestricted double cp2x, unrestricted double cp2y, unrestricted double x, unrestricted double y);
  void <span data-x="dom-context-2d-arcTo">arcTo</span>(unrestricted double x1, unrestricted double y1, unrestricted double x2, unrestricted double y2, unrestricted double radius); 
  void <span data-x="dom-context-2d-rect">rect</span>(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void <span data-x="dom-context-2d-arc">arc</span>(unrestricted double x, unrestricted double y, unrestricted double radius, unrestricted double startAngle, unrestricted double endAngle, optional boolean anticlockwise = false); <!-- see ARC-ORDER note below -->
  void <span data-x="dom-context-2d-ellipse">ellipse</span>(unrestricted double x, unrestricted double y, unrestricted double radiusX, unrestricted double radiusY, unrestricted double rotation, unrestricted double startAngle, unrestricted double endAngle, optional boolean anticlockwise = false); 
};

[Exposed=Window,Worker]
interface CanvasGradient {
  // opaque object
  void addColorStop(double offset, DOMString color);
};

[Exposed=Window,Worker]
interface CanvasPattern {
  // opaque object
  void setTransform(SVGMatrix transform);
};

[Exposed=Window,Worker]
interface TextMetrics {
  // x-direction
  readonly attribute double width; // advance width
  readonly attribute double actualBoundingBoxLeft;
  readonly attribute double actualBoundingBoxRight;

  // y-direction
  readonly attribute double fontBoundingBoxAscent;
  readonly attribute double fontBoundingBoxDescent;
  readonly attribute double actualBoundingBoxAscent;
  readonly attribute double actualBoundingBoxDescent;
  readonly attribute double emHeightAscent;
  readonly attribute double emHeightDescent;
  readonly attribute double hangingBaseline;
  readonly attribute double alphabeticBaseline;
  readonly attribute double ideographicBaseline;
};

dictionary HitRegionOptions {
  Path2D? path = null;
  CanvasFillRule fillRule = "nonzero";
  SVGMatrix? transform = null;
  DOMString id = "";
  DOMString? parentID = null;
  DOMString cursor = "inherit";
  // for control-backed regions:
  Element? control = null;
};

[Constructor(unsigned long sw, unsigned long sh),
 Constructor(Uint8ClampedArray data, unsigned long sw1, optional unsigned long sh1),
 Exposed=Window,Worker]
interface ImageData {
  readonly attribute unsigned long width;
  readonly attribute unsigned long height;
  readonly attribute Uint8ClampedArray data;
};

[Constructor(optional Element scope), Exposed=Window,Worker]
interface <dfn>DrawingStyle</dfn> 
{ };
DrawingStyle implements CanvasDrawingStyles;

[Constructor
 Constructor(Path2D path),
 Constructor(Path2D[] paths, optional CanvasFillRule fillRule = "nonzero"),
 Constructor(DOMString d), Exposed=Window,Worker]
interface Path2D {
  void addPath(Path2D path, optional SVGMatrix? transformation = null);
};

Path2D implements CanvasPathMethods;
</pre>
  <dl class="domintro">

   <dt><var data-x="">context</var> = <var data-x="">canvas</var>.<code>getContext</code>('2d')</dt>

   <dd>

    <p>Returns a <a interface>CanvasRenderingContext2D</a> object that is permanently bound to a
    particular <code>canvas</code> element.</p>

   </dd>

   <dt><var data-x="">context</var> = new <a interface>CanvasRenderingContext2D</a>( [ <var data-x="">width</var>, <var data-x="">height</var> ] )</dt>

   <dd>

    <p>Returns an unbound <a interface>CanvasRenderingContext2D</a> object with an implied bitmap with
    the given dimensions in CSS pixels (300x150, if the arguments are omitted).</p>

   </dd>

   <dt><var data-x="">context</var> . <a link-for=CanvasRenderingContext2D link-type=attribute>canvas</a></dt>

   <dd>

    <p>Returns the <code>canvas</code> element, if the rendering context was obtained using the
    <code>getContext()</code> method.</p>

   </dd>

   <dt><var data-x="">context</var> . <a>width</a></dt>
   <dt><var data-x="">context</var> . <a>height</a></dt>

   <dd>

    <p>Return the dimensions of the bitmap, in CSS pixels.</p>

    <p>Can be set, to update the bitmap's dimensions. If the rendering context is bound to a canvas,
    this will also update the canvas' intrinsic dimensions.</p>

   </dd>

   <dt><var data-x="">context</var> . <a>commit()</a></dt>

   <dd>

    <p>If the rendering context is bound to a <code>canvas</code>, display the current frame.</p>

   </dd>

  </dl>

 <div class="impl">

  <p>A <a interface>CanvasRenderingContext2D</a> object can be obtained in two ways: the <code
  data-x="dom-canvas-getContext">getContext()</code> method on a <a link-for=CanvasRenderingContext2D link-type=attribute>canvas</a> element (which
  invokes the <span>2D context creation algorithm</span>), and the <a>CanvasRenderingContext2D()</a> constructor.</p>

  <p>A <a interface>CanvasRenderingContext2D</a> object has a <dfn>scratch bitmap</dfn> and can be bound
  to an <dfn>output bitmap</dfn>. These are initialised when the object is created, and can be
  subsequently adjusted when the rendering context is <span
  data-x="concept-canvas-binding-steps">bound</span> or <span
  data-x="concept-canvas-unbinding-steps">unbound</span>. In some cases, these bitmaps are the same
  underlying bitmap. In general, the <span>scratch bitmap</span> is what scripts interact with, and
  the <span>output bitmap</span> is what is being displayed. These bitmaps always have the same
  dimensions.</p>

<!--ADD-TOPIC:Security-->
  <p>Each such bitmap has an <span data-x="concept-canvas-origin-clean">origin-clean</span> flag,
  which can be set to true or false. Initially, when one of these bitmaps is created, its <span
  data-x="concept-canvas-origin-clean">origin-clean</span> flag must be set to true.</p>
<!--REMOVE-TOPIC:Security-->

  <p>These bitmaps also have a <a>hit region list</a>, which is described in a later section.
  Initially, this list is empty. <span data-x="scratch bitmap">Scratch bitmaps</span> also have a
  <dfn>list of pending interface actions</dfn>, which can contain instructions to draw the user's
  attention to a location on the bitmap, and instructions to scroll to a location on the bitmap.
  Initially, this list is also empty.</p>

  <p>The <a interface>CanvasRenderingContext2D</a> 2D rendering context represents a flat linear
  Cartesian surface whose origin (0,0) is at the top left corner, with the coordinate space having
  <var>x</var> values increasing when going right, and <var>y</var> values
  increasing when going down. The <var>x</var>-coordinate of the right-most edge is equal to
  the width of the rendering context's <span>scratch bitmap</span> in CSS pixels; similarly, the
  <var>y</var>-coordinate of the bottom-most edge is equal to the height of the rendering
  context's <span>scratch bitmap</span> in CSS pixels.</p>

  <p>The size of the coordinate space does not necessarily represent the size of the actual bitmaps
  that the user agent will use internally or during rendering. On high-definition displays, for
  instance, the user agent may internally use bitmaps with two device pixels per unit in the
  coordinate space, so that the rendering remains at high quality throughout. Anti-aliasing can
  similarly be implemented using over-sampling with bitmaps of a higher resolution than the final
  image on the display.</p>

  <hr>

  <p>The <dfn>2D context creation algorithm</dfn>, which is passed a <var>target</var> (a
  <code>canvas</code> element), consists of running the following steps:</p>

  <ol>

   <li><p>Create a new <a interface>CanvasRenderingContext2D</a> object.</p></li>

   <li><p>Initialise its <a link-for=CanvasRenderingContext2D link-type=attribute><code>canvas</code></a> attribute to point to
   <var>target</var>.</p></li>

   <li><p>Let the new <a interface>CanvasRenderingContext2D</a> object's <span>output bitmap</span> and
   <span>scratch bitmap</span> both be the same bitmap as <var>target</var>'s bitmap (so
   that they are shared).</p></li>

   <li><p><a>Set bitmap dimensions</a> to the
   numeric values of <var>target</var>'s <a link-for=CanvasRenderingContext2D link-type=attribute>width</a> 
   and <a link-for=CanvasRenderingContext2D link-type=attribute>height</a> content attributes.</p></li>

   <li><p>Return the new <a interface>CanvasRenderingContext2D</a> object.</p></li>

  </ol>

  <hr>

  <p>The <dfn dfn-type=constructor dfn-for=CanvasRenderingContext2D>CanvasRenderingContext2D()</dfn> constructor, when
  invoked, must run the following steps:</p>

  <ol>

   <li><p>Create a new <a interface>CanvasRenderingContext2D</a> object.</p></li>

   <li><p>Initialise its <a link-for=CanvasRenderingContext2D link-type=attribute><code>canvas</code></a> attribute to
   null.</p></li>

   <li><p>Let the new <a interface>CanvasRenderingContext2D</a> object's <span>scratch bitmap</span> be
   a new bitmap.</p></li>

   <li><p>If the constructor was called with arguments, let <var>width</var> and <var>height</var> be the first
  and second arguments, respectively. Otherwise, let <var>width</var> and <var>height</var> be 300 and 150, respectively.</p></li>

   <li><p><a>set bitmap dimensions</a> to <var>width</var> and <var>height</var>.</p></li>

   <li><p>Let the new <a interface>CanvasRenderingContext2D</a> object have no <span>output
   bitmap</span>.</p></li>


   <li><p>Return the new <a interface>CanvasRenderingContext2D</a> object.</p></li>

  </ol>

  <hr>

  <p>When the user agent is required to <dfn>commit the scratch bitmap</dfn> for a rendering
  context, it must run the following steps:

  <ol>

   <li><p>Let <var>bitmap copy</var> be a copy of the rendering context's <span>scratch
   bitmap</span>.</p></li>

<!--ADD-TOPIC:Security-->
   <li><p>Let <var>origin-clean flag copy</var> be a copy of the rendering context's
   <span>scratch bitmap</span>'s <span data-x="concept-canvas-origin-clean">origin-clean</span>
   flag.</p></li>
<!--REMOVE-TOPIC:Security-->

   <li><p>Let <var>hit region list copy</var> be a copy of the rendering context's
   <span>scratch bitmap</span>'s <a>hit region list</a>.</p></li>

   <li><p>Let <var>list of pending interface actions copy</var> be a copy of the rendering
   context's <span>scratch bitmap</span>'s <span>list of pending interface actions</span>.</p></li>

   <li><p>Empty the <span>scratch bitmap</span>'s <span>list of pending interface actions</span>.</p></li>

   <li><p>If the rendering context has no <span>output bitmap</span>, abort these steps.</p></li>

   <li><p>Let <var>output bitmap</var> be the rendering context's <span>output
   bitmap</span>.</p></li>

   <li><p>Let <a link-for=CanvasRenderingContext2D link-type=attribute><var>canvas</var></a> be the <code>canvas</code> element to which the rendering
   context was most recently <span data-x="concept-canvas-binding-steps">bound</span>.</p></li>

   <li>

    <p><span>Queue a task</span> associated with <var>canvas</var>' <code>Document</code>
    to perform the following substeps:</p>

    <ol>

     <li><p>Overwrite <var>output bitmap</var> with <var>bitmap
     copy</var>.</p></li>

<!--ADD-TOPIC:Security-->
     <li><p>Overwrite <var>output bitmap</var>'s <span
     data-x="concept-canvas-origin-clean">origin-clean</span> flag with <var>origin-clean
     flag copy</var>.</p></li>
<!--REMOVE-TOPIC:Security-->

     <li><p>Overwrite <var>output bitmap</var>'s <a>hit region list</a> with <var
     data-x="">hit region list copy</var>.</p></li>

     <li><p>Follow the directions in the <var>list of pending interface actions
     copy</var>.</p></li>

    </ol>

   </li>

  </ol>

  <p>The algorithm above must use the <dfn>canvas updating task source</dfn> (which is just used by
  this algorithm).</p>

  <p>The <dfn dfn-for=CanvasRenderingContext2D dfn-type=method><code>commit()</code></dfn> method must run the
  following steps:</p>

  <ol>

   <li><p>If the rendering context's <span data-x="concept-canvas-context-bitmap-mode">context bitmap
   mode</span> is <span data-x="concept-canvas-bound">fixed</span>, throw an
   <code>InvalidStateError</code> exception and abort these steps.</p></li>

   <li><p><span>Commit the scratch bitmap</span> for the rendering context.</p></li>

  </ol>

  <p class="note">The <span>scratch bitmap</span> is only <span data-x="commit the scratch
  bitmap">committed</span> when the <a link-for=CanvasRenderingContext2D link-type=method>commit()</a> method is
  called. (This doesn't matter for <code>canvas</code> elements in <span
  data-x="concept-canvas-direct-2d">direct-2d</span> mode, since there the <span>scratch
  bitmap</span> is also the <code>canvas</code> element's bitmap so every drawing operation is
  immediately drawn.)</p>

  <hr>

  <p>When the user agent is to <dfn>set bitmap dimensions</dfn> to <var>width</var> and <var>height</var>, it must run the
  following steps:</p>

  <ol>

   <li><p><span>Reset the rendering context to its default state</span>.</p></li>

   <li><p>Clear the <span>scratch bitmap</span>'s <a>hit region list</a> and its <span>list of
   pending interface actions</span>.</p></li>

   <li><p>Resize the <span>scratch bitmap</span> to the new <var>width</var> and <var
   data-x="">height</var> and clear it to fully transparent black.</p></li>

   <li><p>If the rendering context has an <span>output bitmap</span>, and the <span>scratch
   bitmap</span> is a different bitmap than the <span>output bitmap</span>, then resize the
   <span>output bitmap</span> to the new <var>width</var> and <var>height</var>
   and clear it to fully transparent black.</p></li>

   <li>

    <p>If the rendering context's <span data-x="concept-canvas-context-bitmap-mode">context bitmap
    mode</span> is <span data-x="concept-canvas-fixed">fixed</span>, then run these substeps:</p>

    <ol>

     <li><p>Let <var>canvas</var> be the <code>canvas</code> element to which the rendering
     context's <a link-for=CanvasRenderingContext2D link-type=attribute><code>canvas</code></a> attribute was initialized.</p></li>

     <li><p>If the rendering context's <span data-x="concept-canvas-context-bitmap-mode">context
     bitmap mode</span> is <span data-x="concept-canvas-fixed">fixed</span> and the numeric value of
     the <var>canvas</var>' <a link-for=CanvasRenderingContext2D link-type=attribute>width</a> content attribute
     differs from <var>width</var>, then set <var>canvas</var>' <a link-for=CanvasRenderingContext2D link-type=attribute>width</a> 
     content attribute to the shortest possible string
     representing <var>width</var> as a <span>valid non-negative integer</span>.</p></li>

     <li><p>If the rendering context's <span data-x="concept-canvas-context-bitmap-mode">context
     bitmap mode</span> is <span data-x="concept-canvas-fixed">fixed</span> and the numeric value of
     the <var>canvas</var>' <a link-for=CanvasRenderingContext2D link-type=attribute>height</a> content attribute
     differs from <var>height</var>, then set <var>canvas</var>' <a link-for=CanvasRenderingContext2D link-type=attribute>height</a> 
     content attribute to the shortest possible strings
     representing <var>height</var> as a <span>valid non-negative integer</span>.</p></li>

    </ol>

   </li>

  </ol>

  <div class="example">
   <p>Only one square appears to be drawn in the following example:</p>
   <pre>// canvas is a reference to a &lt;canvas> element
var context = canvas.getContext('2d');
context.fillRect(0,0,50,50);
canvas.setAttribute('width', '300'); // clears the canvas
context.fillRect(0,100,50,50);
canvas.width = canvas.width; // clears the canvas
context.fillRect(100,0,50,50); // only this square remains</pre>
  </div>

  <hr>

  <p>When the user agent is to run the <dfn data-x="concept-canvas-unbinding-steps">unbinding
  steps</dfn> for a rendering context, it must run the following steps:</p>

  <ol>

   <li><p><span>Reset the rendering context to its default state</span>.</p></li>

   <li><p>Clear the <span>scratch bitmap</span>'s <a>hit region list</a> and its <span>list of
   pending interface actions</span>.</p></li>

   <li><p>Clear the <a interface>CanvasRenderingContext2D</a> object's <span>scratch bitmap</span> to a
   transparent black.</p></li>

<!--ADD-TOPIC:Security-->
   <li><p>Set the <a interface>CanvasRenderingContext2D</a> object's <span>scratch bitmap</span>'s <span
   data-x="concept-canvas-origin-clean">origin-clean</span> flag to true.</p></li>
<!--REMOVE-TOPIC:Security-->

   <li><p>Let the <a interface>CanvasRenderingContext2D</a> object have no <span>output
   bitmap</span>.</p></li>

  </ol>

  <p>When the user agent is to run the <dfn data-x="concept-canvas-binding-steps">binding steps</dfn>
  to bind the rendering context to the <code>canvas</code> element <var>target</var>, it
  must run the following steps:</p>

  <ol>

   <li><p><span>Reset the rendering context to its default state</span>.</p></li>

   <li><p>Clear the <span>scratch bitmap</span>'s <a>hit region list</a> and its <span>list of
   pending interface actions</span>.</p></li>

   <li><p>Resize the <a interface>CanvasRenderingContext2D</a> object's <span>scratch bitmap</span> to
   the dimensions of <var>target</var>'s bitmap and clear it to fully transparent
   black.</p></li>

<!--ADD-TOPIC:Security-->
   <li><p>Set the <a interface>CanvasRenderingContext2D</a> object's <span>scratch bitmap</span>'s <span
   data-x="concept-canvas-origin-clean">origin-clean</span> flag to true.</p></li>
<!--REMOVE-TOPIC:Security-->

   <li><p>Let the <a interface>CanvasRenderingContext2D</a> object's <span>output bitmap</span> be <var
   data-x="">target</var>'s bitmap.</p></li>

  </ol>

  <hr>

  <p>The <dfn dfn-for=CanvasRenderingContext2D dfn-type=attribute><code>canvas</code></dfn> attribute must return the
  value it was initialised to when the object was created.</p>

  <p>The <dfn dfn-for=CanvasRenderingContext2D dfn-type=attribute><code>width</code></dfn> attribute, on getting, must
  return the width of the rendering context's <span>scratch bitmap</span>, in CSS pixels. On
  setting, it must <a>set bitmap dimensions</a>
  to the new value and the current height of the rendering context's <span>scratch bitmap</span> in
  CSS pixels, respectively.</p>

  <p>The <dfn dfn-for=CanvasRenderingContext2D dfn-type=attribute><code>height</code></dfn> attribute, on getting, must
  return the height of the rendering context's <span>scratch bitmap</span>, in CSS pixels. On
  setting, it must <a>set bitmap dimensions</a>
  to the current width of the rendering context's <span>scratch bitmap</span> in CSS pixels and the
  new value, respectively.</p>

  <hr>

  <p>Except where otherwise specified, for the 2D context interface, <strong>any method call with a
  numeric argument whose value is infinite or a NaN value must be ignored</strong>.</p>

  <p>Whenever the CSS value <code data-x="">currentColor</code> is used as a color in the
  <a interface>CanvasRenderingContext2D</a> API, the "computed value of the 'color' property" for the
  purposes of determining the computed value of the <code data-x="">currentColor</code> keyword is
  the value described by the appropriate entry in the following list:</p>

  <dl>

   <dt>If the rendering context's <span data-x="concept-canvas-context-bitmap-mode">context bitmap
   mode</span> is <span data-x="concept-canvas-fixed">fixed</span> and the <code>canvas</code>
   element is <span>being rendered</span></dt>

   <dd><p>The "computed value of the 'color' property" for the purposes of determining the computed
   value of the <code data-x="">currentColor</code> keyword is the computed value of the 'color'
   property on the <code>canvas</code> element at the time that the color is specified (e.g. when
   the appropriate attribute is set, or when the method is called; not when the color is rendered or
   otherwise used). <a href="#refsCSSCOLOR">[CSSCOLOR]</a></p></dd>

   <dt>In all other cases</dt>

   <dd><p>The "computed value of the 'color' property" for the purposes of determining the computed
   value of the <code data-x="">currentColor</code> keyword is fully opaque black. <a
   href="#refsCSSCOLOR">[CSSCOLOR]</a></p></dd>

  </dl>

  <p>In the case of <code data-x="dom-canvasgradient-addColorStop">addColorStop()</code> on
  <code>CanvasGradient</code>, the "computed value of the 'color' property" for the purposes of
  determining the computed value of the <code data-x="">currentColor</code> keyword is always fully
  opaque black (there is no associated element). <a href="#refsCSSCOLOR">[CSSCOLOR]</a></p>

  <p class="note">This is because <code>CanvasGradient</code> objects are
  <code>canvas</code>-neutral &mdash; a <code>CanvasGradient</code> object created by one
  <code>canvas</code> can be used by another, and there is therefore no way to know which is the
  "element in question" at the time that the color is specified.</p>

  <p class="note">Similar concerns exist with font-related properties; the rules for those are
  described in detail in the relevant section below.</p>

  </div>

  <hr>

  <p>The <dfn dfn-type=enum><code>CanvasFillRule</code></dfn> enumeration is used to select the <dfn>fill rule</dfn>
  algorithm by which to determine if a point is inside or outside a path.</p>

  <p>The value "<dfn value for=CanvasFillRule><code>nonzero</code></dfn>" value
  indicates the non-zero winding rule, wherein a point is considered to be outside a shape if the number of times a half-infinite straight
  line drawn from that point crosses the shape's path going in one direction is equal to the
  number of times it crosses the path going in the other direction.
  </p>


  <p>The "<dfn value for=CanvasFillRule"><code>evenodd</code></dfn>" value indicates
  the even-odd rule, wherein a point is considered to be outside a shape if the number of times a half-infinite straight
  line drawn from that point crosses the shape's path is even.
  </p>

  <p>If a point is not outside a shape, it is inside the shape.</p>


  <h2 id="implementation-notes" title="notes on canvas 2D implementation">Implementation notes</h2>

  <!-- NON-NORMATIVE SECTION -->

  <p>Although the way the specification is written it might sound like an implementation needs to
  track up to four bitmaps per canvas or rendering context &mdash; one <span>scratch bitmap</span>,
  one <span>output bitmap</span> for the rendering context, one bitmap for the <code>canvas</code>,
  and one bitmap for the actually currently rendered image &mdash; user agents can in fact generally
  optimise this to only one or two.</p>

  <p>The <span>scratch bitmap</span>, when it isn't the same bitmap as the <span>output
  bitmap</span>, is only directly observable if it is read, and therefore implementations can,
  instead of updating this bitmap, merely remember the sequence of drawing operations that have been
  applied to it until such time as the bitmap's actual data is needed (for example because of a call
  to <a link-for=CanvasRenderingContext2D link-type=method>commit()</a>, <code
  data-x="dom-context-2d-drawImage">drawImage()</code>, or the <code data-x="dom-createImageBitmap">createImageBitmap()</code>
  factory method). In many cases, this will be more memory efficient.</p>

  <p>The bitmap of a <code>canvas</code> element is the one bitmap that's pretty much always going
  to be needed in practice. The <span>output bitmap</span> of a rendering context, when it has one,
  is always just an alias to a <code>canvas</code> element's bitmap.</p>

  <p>Additional bitmaps are sometimes needed, e.g. to enable fast drawing when the canvas is being
  painted at a different size than its intrinsic size, or to enable double buffering so that the
  rendering commands from the <span>scratch bitmap</span> can be applied without the rendering being
  updated midway.</p>




  <h2 id="canvas-state" title="description of the canvas state">The canvas state</h2>

  <p>Each <a interface>CanvasRenderingContext2D</a> rendering context maintains a stack of drawing
  states. <dfn data-x="drawing state">Drawing states</dfn> consist of:</p>

  <ul class="brief">
   <li>The current <span data-x="dom-context-2d-transformation">transformation matrix</span>.</li>
   <li>The current <span>clipping region</span>.</li>
   <li>The current values of the following attributes: 
   <a link-for=CanvasRenderingContext2D link-type=attribute>strokeStyle</a>, 
   <a link-for=CanvasRenderingContext2D link-type=attribute>fillStyle</a>, <a
   link-for=CanvasRenderingContext2D link-type=attribute>globalAlpha</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>lineWidth</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>lineCap</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>lineJoin</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>miterLimit</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>lineDashOffset</a>, <a
   link-for=CanvasRenderingContext2D link-type=attribute>shadowOffsetX</a>, <a
   link-for=CanvasRenderingContext2D link-type=attribute>shadowOffsetY</a>, <a
   link-for=CanvasRenderingContext2D link-type=attribute>shadowBlur</a>, <a
   link-for=CanvasRenderingContext2D link-type=attribute>shadowColor</a>, <a
   link-for=CanvasRenderingContext2D link-type=attribute>globalCompositeOperation</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>font</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>textAlign</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>textBaseline</a>, <a
   link-for=CanvasDrawingStyles link-type=attribute>direction</a>, <a
   link-for=CanvasRenderingContext2D link-type=attribute>imageSmoothingEnabled</a>.</li>
   <li>The current <a link-for=CanvasDrawingStyles link-type=attribute>dash list</a>.</li>
  </ul>

  <p class="note">The <span>current default path</span> and the rendering context's bitmaps are not
  part of the drawing state. The <span>current default path</span> is persistent, and can only be
  reset using the <code data-x="dom-context-2d-beginPath">beginPath()</code> method. The bitmaps
  depend on whether and how the rendering context is bound to a <code>canvas</code> element.</p>

  <dl class="domintro">

   <dt><var>context</var>.<a link-for=CanvasRenderingContext2D link-type=method><code>save()</code></a></dt>

   <dd>

    <p>Pushes the current state onto the stack.</p>

   </dd>

   <dt><var>context</var>.<a link-for=CanvasRenderingContext2D link-type=method><code>restore()</code></a></dt>

   <dd>

    <p>Pops the top state on the stack, restoring the context to that state.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn dfn-for=CanvasRenderingContext2D dfn-type=method><code>save()</code></dfn> method must push a copy of the
  current drawing state onto the drawing state stack.</p>

  <p>The <dfn dfn-for=CanvasRenderingContext2D dfn-type=method><code>restore()</code></dfn> method must pop the top
  entry in the drawing state stack, and reset the drawing state it describes. If there is no saved
  state, the method must do nothing.</p>

  <p>When the user agent is to <dfn>reset the rendering context to its default state</dfn>, it must
  clear the drawing state stack and everything that <span>drawing state</span> consists of to
  initial values.</p>


  </div>


  <h2 id="drawingstyle-id" title="describe elements of the drawing style object"><code>DrawingStyle</code> objects</h2>

  <p>All the line styles (line width, caps, joins, and dash patterns) and text styles (fonts)
  described in the next two sections apply to <a interface>CanvasRenderingContext2D</a> objects and to
  <a interface><code>DrawingStyle</code></a> objects. This section defines the constructor used to obtain a
  <a interface><code>DrawingStyle</code></a> object. This object is then used by methods on <code>Path2D</code>
  objects to control how text and paths are rasterised and stroked.</p>

  <dl class="domintro">

   <dt><var>styles</var> = new <a interface><code>DrawingStyle</code></a>( [ <var>element</var> ] )</dt>

   <dd>

    <p>Creates a new <a interface><code>DrawingStyle</code></a> object, optionally using a specific element for
    resolving relative keywords and sizes in font specifications.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Each <a interface><code>DrawingStyle</code></a> object can have a <dfn>styles scope object</dfn>.</p>

  <p>The <dfn dfn-for=DrawingStyle dfn-type=constructor>DrawingStyle()</dfn> constructor, when invoked,
  must return a newly created <a interface><code>DrawingStyle</code></a> object. If the constructor was passed an
  argument, then the <a interface><code>DrawingStyle</code></a> object's <span>styles scope object</span> is that
  element. Otherwise, if the <span>JavaScript global environment</span> is a <span>document
  environment</span>, the object's <span>styles scope object</span> is the <code>Document</code>
  object of the <span>active document</span> of the <span>browsing context</span> of the
  <code>Window</code> object on which the interface object of the invoked constructor is found.
  Otherwise, the <span>JavaScript global environment</span> is a <span>worker environment</span>,
  and the <span>styles scope object</span> is the worker.</p>

  </div>

<h2 id="line-styles" title="description of canvas line styles">Line styles</h2>

  <dl class="domintro">

   <dt><var>context</var> . <a link-for=CanvasDrawingStyles attribute><code>lineWidth</code></a> [ = <var>value</var> ]</dt>
   <dt><var>styles</var> . <a link-for=CanvasDrawingStyles attribute><code>lineWidth</code></a> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the current line width.</p>

    <p>Can be set, to change the line width. Values that are not finite values greater than zero are
    ignored.</p>

   </dd>

   <dt><var>context</var> . <a link-for=CanvasDrawingStyles attribute><code>lineCap</code></a> [ = <var>value</var> ]</dt>
   <dt><var>styles</var> . <a link-for=CanvasDrawingStyles attribute><code>lineCap</code></a> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the current line cap style.</p>

    <p>Can be set, to change the line cap style.</p>

    <p>The possible line cap styles are <code>butt</code>, <code>round</code>, and
    <code>square</code>. Other values are ignored.</p>

   </dd>

   <dt><var>context</var> . <a link-for=CanvasDrawingStyles attribute><code>lineJoin</code></a> [ = <var>value</var> ]</dt>
   <dt><var>styles</var> . <a link-for=CanvasDrawingStyles attribute><code>lineJoin</code></a> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the current line join style.</p>

    <p>Can be set, to change the line join style.</p>

    <p>The possible line join styles are <code>bevel</code>, <code>round</code>, and
    <code>miter</code>. Other values are ignored.</p>

   </dd>

   <dt><var>context</var> . <a link-for=CanvasDrawingStyles attribute><code>miterLimit</code></a> [ = <var>value</var> ]</dt>
   <dt><var>styles</var> . <a link-for=CanvasDrawingStyles attribute><code>miterLimit</code></a> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the current miter limit ratio.</p>

    <p>Can be set, to change the miter limit ratio. Values that are not finite values greater than
    zero are ignored.</p>

   </dd>


   <dt><var>context</var> . <a link-for=CanvasDrawingStyles method><code>setLineDash(<var>segments</var>)</code></a></dt>
   <dt><var>styles</var> . <a link-for=CanvasDrawingStyles miethd><code>setLineDash(<var>segments</var>)</code></a></dt>

   <dd>

    <p>Sets the current line dash pattern (as used when stroking). The argument is a list of
    distances for which to alternately have the line on and the line off.</p>

   </dd>


   <dt><var>segments</var> = <var>context</var> . <a link-for=CanvasDrawingStyles method><code>getLineDash()</code></a></dt>
   <dt><var>segments</var> = <var>styles</var> . <a link-for=CanvasDrawingStyles method><code>getLineDash()</code></a></dt>

   <dd>

    <p>Returns a copy of the current line dash pattern. The array returned will always have an even
    number of entries (i.e. the pattern is normalized).</p>

   </dd>


   <dt><var>context</var> . <a link-for=CanvasDrawingStyles attribute><code>lineDashOffset</code></a></dt>
   <dt><var>styles</var> . <a link-for=CanvasDrawingStyles attribute><code>lineDashOffset</code></a></dt>

   <dd>

    <p>Returns the phase offset (in the same units as the line dash pattern).</p>

    <p>Can be set, to change the phase offset. Values that are not finite values are ignored.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Objects that implement the <a interface>CanvasDrawingStyles</a> interface have attributes and
  methods (defined in this section) that control how lines are treated by the object.</p>

  <p>The <dfn dfn-for=CanvasDrawingStyles dfn-type=attribute><code>lineWidth</code></dfn> attribute gives the
  width of lines, in coordinate space units. On getting, it must return the current value. On
  setting, zero, negative, infinite, and NaN values must be ignored, leaving the value unchanged;
  other values must change the current value to the new value.</p>

  <p>When the object implementing the <a interface><code>CanvasDrawingStyles</code></a> interface is created, the
  <a link-for=CanvasDrawingStyles attribute><code>lineWidth</code></a> attribute must initially have the value
  <code>1.0</code>.</p>

  <hr>

  <p>The <dfn dfn-for=CanvasDrawingStyles dfn-type=attribute><code>lineCap</code></dfn> attribute defines the type
  of endings that UAs will place on the end of lines. The three valid values are <code>butt</code>,
  <code>round</code>, and <code>square</code>.</p>

  <p>On getting, it must return the current value. On setting, if the new value is one of the
  literal strings <code>butt</code>, <code>round</code>, and <code>square</code>, then the current
  value must be changed to the new value; other values must ignored, leaving the value
  unchanged.</p>

  <p>When the object implementing the <a interface><code>CanvasDrawingStyles</code></a> interface is created, the
  <a link-for=CanvasDrawingStyles attribute><code>lineCap</code></a> attribute must initially have the value
  <code>butt</code>.</p>

  <hr>

  <p>The <dfn dfn-for=CanvasDrawingStyles dfn-type=attribute><code>lineJoin</code></dfn> attribute defines the type
  of corners that UAs will place where two lines meet. The three valid values are
  <code>bevel</code>, <code>round</code>, and <code>miter</code>.</p>

  <p>On getting, it must return the current value. On setting, if the new value is one of the
  literal strings <code>bevel</code>, <code>round</code>, and <code>miter</code>, then the current
  value must be changed to the new value; other values must be ignored, leaving the value
  unchanged.</p>

  <p>When the object implementing the <a interface><code>CanvasDrawingStyles</code></a> interface is created, the
  <a link-for=CanvasDrawingStyles attribute><code>lineJoin</code></a> attribute must initially have the value
  <code>miter</code>.</p>

  <hr>

  <p>When the <a link-for=CanvasDrawingStyles attribute><code>lineJoin</code></a> attribute has the value
  <code>miter</code>, strokes use the miter limit ratio to decide how to render joins. The miter
  limit ratio can be explicitly set using the <dfn dfn-for=CanvasDrawingStyles dfn-type=attribute>
  <code>miterLimit</code></dfn> attribute. On getting, it must
  return the current value. On setting, zero, negative, infinite, and NaN values must be ignored,
  leaving the value unchanged; other values must change the current value to the new value.</p>
  <!-- values less than 1.0 are equivalent to 1.0, since it's compared
       against a ratio that can't be less than 1.0 -->

  <p>When the object implementing the <a interface><code>CanvasDrawingStyles</code></a> interface is created, the
  <a link-for=CanvasDrawingStyles attribute><code>miterLimit</code></a> attribute must initially have the value
  <code>10.0</code>.</p>

  <hr>

  <p>Each <a interface><code>CanvasDrawingStyles</code></a> object has a <dfn dfn-for=CanvasDrawingStyles dfn-type=attribute>dash list</dfn>, which is either empty
  or consists of an even number of non-negative numbers. Initially, the <a link-for=CanvasDrawingStyles link-type=attribute>dash list</a> must
  be empty.</p>

  <p>When the <dfn dfn-for=CanvasDrawingStyles dfn-type=method><code>setLineDash()</code></dfn> method is
  invoked, it must run the following steps:</p>

  <ol>

   <li><p>Let <var>a</var> be the argument.</p></li>

   <li><p>If any value in <var>a</var> is not finite (e.g. an Infinity or a NaN value), or
   if any value is negative (less than zero), then abort these steps (without throwing an exception;
   user agents could show a message on a developer console, though, as that would be helpful for
   debugging).</p></li>

   <li><p>If the number of elements in <var>a</var> is odd, then let <var>a</var>
   be the concatentation of two copies of <var>a</var>.</p></li>

   <li><p>Let the object's <a link-for=CanvasDrawingStyles link-type=attribute>dash list</a> be <var>a</var>.</p></li>

  </ol>

  <p>When the <dfn dfn-for=CanvasDrawingStyles dfn-type=method><code>getLineDash()</code></dfn> method is
  invoked, it must return a sequence whose values are the values of the object's <span>dash
  list</span>, in the same order.</p>

  <p>It is sometimes useful to change the "phase" of the dash pattern, e.g. to achieve a "marching
  ants" effect. The phase can be set using the <dfn
   dfn-for=CanvasDrawingStyles dfn-type=attribute><code>lineDashOffset</code></dfn> attribute. On getting, it
  must return the current value. On setting, infinite and NaN values must be ignored, leaving the
  value unchanged; other values must change the current value to the new value.</p>

  <p>When the object implementing the <a interface><code>CanvasDrawingStyles</code></a> interface is created, the
  <a link-for=CanvasDrawingStyles attribute><code>lineDashOffset</code></a> attribute must initially have
  the value <code>0.0</code>.</p>

  <hr>

  <p>When a user agent is to <dfn>trace a path</dfn>, <!-- <dfn>trace a path</dfn> -->
  given an object <var>style</var> that implements the <a interface><code>CanvasDrawingStyles</code></a>
  interface, it must run the following algorithm. This algorithm returns a new <span
  data-x="concept-path">path</span>.</p>

  <ol>

   <li><p>Let <var>path</var> be a copy of the path being traced.</p></li>

   <!-- PATH SANITIZATION -->

   <li><p>Prune all zero-length <span>line segments</span> from <var>path</var>.</p></li>

   <li><p>Remove from <var>path</var> any subpaths containing no lines (i.e. subpaths with
   just one point).</p></li>

   <li><p>Replace each point in each subpath of <var>path</var> other than the first point
   and the last point of each subpath by a <b>join</b> that joins the line leading to that point to
   the line leading out of that point, such that the subpaths all consist of two points (a starting
   point with a line leading out of it, and an ending point with a line leading into it), one or
   more lines (connecting the points and the joins), and zero or more joins (each connecting one
   line to another), connected together such that each subpath is a series of one or more lines with
   a join between each one and a point on each end.</p></li>

   <li><p>Add a straight closing line to each closed subpath in <var>path</var> connecting
   the last point and the first point of that subpath; change the last point to a join (from the
   previously last line to the newly added closing line), and change the first point to a join (from
   the newly added closing line to the first line).</p>

   <li><p>If the <var>styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>dash list</a> is empty, jump to the step
   labeled <b>convert</b>.</p></li>

   <!-- DASHING -->

   <li><p>Let <var>pattern width</var> be the concatenation of all the entries of the <var
   data-x="">styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>dash list</a>, in coordinate space units.</p>

   <li><p>For each subpath <var>subpath</var> in <var>path</var>, run the
   following substeps. These substeps mutate the subpaths in <var>path</var> <b>in
   vivo</b>.</p>

    <ol>

     <li><p>Let <var>subpath width</var> be the length of all the lines of <var
     data-x="">subpath</var>, in coordinate space units.</p>

     <li><p>Let <var>offset</var> be the value of the <var>styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>lineDashOffset</a>, 
     in coordinate space units.</p></li>

     <li>

      <p>While <var>offset</var> is greater than <var>pattern width</var>,
      decrement it by <var>pattern width</var>.</p>

      <p>While <var>offset</var> is less than zero, increment it by <var>pattern
      width</var>.</p>

     </li>

     <li><p>Define <var>L</var> to be a linear coordinate line defined along all lines in
     <var>subpath</var>, such that the start of the first line in the subpath is defined
     as coordinate 0, and the end of the last line in the subpath is defined as coordinate <var
     data-x="">subpath width</var>.</p></li>

     <li><p>Let <var>position</var> be zero minus <var>offset</var>.</p></li>

     <li><p>Let <var>index</var> be 0.</p></li>

     <li><p>Let <var>current state</var> be <b>off</b> (the other states being <b>on</b>
     and <b>zero-on</b>).</p></li>

     <li><p><b>Dash on</b>: Let <var>segment length</var> be
     the value of the <var>styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>dash
     list</a>'s <var>index</var>th entry.</p></li>

     <li><p>Increment <var>position</var> by <var>segment length</var>.</p></li>

     <li><p>If <var>position</var> is greater than <var>subpath width</var>, then
     end these substeps for this subpath and start them again for the next subpath; if there are no
     more subpaths, then jump to the step labeled <b>convert</b> instead.</p></li>

     <li><p>If <var>segment length</var> is non-zero, let <var
     data-x="">current state</var> be <b>on</b>.</p></li>

     <li><p>Increment <var>index</var> by one.</p></li>

     <li><p><b>Dash off<!-- labeled for consistency only --></b>: Let <var>segment
     length</var> be the value of the <var>styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>dash list</a>'s <var
     data-x="">index</var>th entry.</p></li>

     <li><p>Let <var>start</var> be the offset <var>position</var> on <var
     data-x="">L</var>.</p></li>

     <li><p>Increment <var>position</var> by <var>segment length</var>.</p></li>

     <li><p>If <var>position</var> is less than zero, then jump to the step labeled
     <b>post-cut</b>.</p></li> <!-- start and end both before zero -->

     <li><p>If <var>start</var> is less than zero, then let <var>start</var> be
     zero.</p></li> <!-- end will be (at or) after zero -->

     <li><p>If <var>position</var> is greater than <var>subpath width</var>, then
     let <var>end</var> be the offset <var>subpath width</var> on <var
     data-x="">L</var>. Otherwise, let <var>end</var> be the offset <var
     data-x="">position</var> on <var>L</var>.</p></li>

     <li>

      <p>Jump to the first appropriate step:</p>

      <dl class="switch">

       <dt>If <var>segment length</var> is zero and <var>current state</var> is <b>off</b></dt>

       <dd>

        <p>Do nothing, just continue to the next step.</p>

       </dd>


       <dt>If <var>current state</var> is <b>off</b></dt>

       <dd>

        <p>Cut the line on which <var>end</var> finds itself short at <var
        data-x="">end</var> and place a point there, cutting the subpath that it was in in two;
        remove all line segments, joins, points, and subpaths that are between <var
        data-x="">start</var> and <var>end</var>; and finally place a single point at <var
        data-x="">start</var> with no lines connecting to it.</p>

        <p>The point has a <b>directionality</b> for the purposes of drawing line caps (see below).
        The directionality is the direction that the original line had at that point (i.e. when <var
        data-x="">L</var> was defined above).</p>

       </dd>


       <dt>Otherwise</dt>

       <dd>

        <p>Cut the line on which <var>start</var> finds itself into two at <var
        data-x="">start</var> and place a point there, cutting the subpath that it was in in two, and
        similarly cut the line on which <var>end</var> finds itself short at <var
        data-x="">end</var> and place a point there, cutting the subpath that <em>it</em> was in in
        two, and then remove all line segments, joins, points, and subpaths that are between <var
        data-x="">start</var> and <var>end</var>.</p>

        <p>If <var>start</var> and <var>end</var> are the same point, then this
        results in just the line being cut in two and two points being inserted there, with nothing
        being removed, unless a join also happens to be at that point, in which case the join must
        be removed.</p>

       </dd>

      </dl>

     </li>

     <li><p><b>Post-cut</b>: If <var>position</var> is greater than <var
     data-x="">subpath width</var>, then jump to the step labeled <b>convert</b>.</p></li>

     <li><p>If <var>segment length</var> is greater than zero, let <var
     data-x="">positioned-at-on-dash</var> be false.</p></li>

     <li><p>Increment <var>index</var> by one. If it is equal to the number of entries in
     the <var>styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>dash list</a>, then let <var>index</var> be
     0.</p></li>

     <li><p>Return to the step labeled <b>dash on</b>.</p></li>

    </ol>

   </li>
    <!-- STROKING -->

   <li>

    <p><b>Convert</b>: This is the step that converts the path to a new path that represents its
    stroke.</p>

    <p>Create a new <span data-x="concept-path">path</span> that describes the edge of the areas
    that would be covered if a straight line of length equal to the <var>styles</var>
    <a link-for=CanvasDrawingStyles link-type=attribute>lineWidth</a> was swept along each subpath in <var
    data-x="">path</var> while being kept at an angle such that the line is orthogonal to the path
    being swept, replacing each point with the end cap necessary to satisfy the <var
    data-x="">styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>lineCap</a> attribute as
    described previously and elaborated below, and replacing each join with the join necessary to
    satisfy the <var>styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>lineJoin</a> type, as defined below.</p>

    <p><strong>Caps</strong>: Each point has a flat edge perpendicular to the direction of the line
    coming out of it. This is them augmented according to the value of the <var
    data-x="">styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>lineCap</a>. The
    <code>butt</code> value means that no additional line cap is added. The <code>round</code> value
    means that a semi-circle with the diameter equal to the <var>styles</var> <a link-for=CanvasDrawingStyles 
    link-type=attribute>lineWidth</a> width must additionally be placed on to the
    line coming out of each point. The <code>square</code> value means that a rectangle with the
    length of the <var>styles</var> <a link-for=CanvasDrawingStyles link-type=attribute>lineWidth</a> 
    width and the width of half the <var data-x="">styles</var> <a link-for=CanvasDrawingStyles 
    link-type=attribute>lineWidth</a> width, placed
    flat against the edge perpendicular to the direction of the line coming out of the point, must
    be added at each point.</p>

    <p>Points with no lines coming out of them must have two caps placed back-to-back as if it was
    really two points connected to each other by an infinitesimally short straight line in the
    direction of the point's <b>directionality</b> (as defined above).</p>

    <p><strong>Joins</strong>: In addition to the point where a join occurs, two additional points
    are relevant to each join, one for each line: the two corners found half the line width away
    from the join point, one perpendicular to each line, each on the side furthest from the other
    line.</p>

    <p>A triangle connecting these two opposite corners with a straight line, with the third point
    of the triangle being the join point, must be added at all joins. The <a 
    link-for=CanvasDrawingStyles link-type=attribute>lineJoin</a> attribute controls whether anything else is
    rendered. The three aforementioned values have the following meanings:</p>

    <p>The <code>bevel</code> value means that this is all that is rendered at joins.</p>

    <p>The <code>round</code> value means that an arc connecting the two aforementioned corners of
    the join, abutting (and not overlapping) the aforementioned triangle, with the diameter equal to
    the line width and the origin at the point of the join, must be added at joins.</p>

    <p>The <code>miter</code> value means that a second triangle must (if it can given the miter
    length) be added at the join, with one line being the line between the two aforementioned
    corners, abutting the first triangle, and the other two being continuations of the outside edges
    of the two joining lines, as long as required to intersect without going over the miter
    length.</p>

    <p>The miter length is the distance from the point where the join occurs to the intersection of
    the line edges on the outside of the join. The miter limit ratio is the maximum allowed ratio of
    the miter length to half the line width. If the miter length would cause the miter limit ratio
    (as set by the <var>style</var> <a link-for=CanvasDrawingStyles link-type=attribute>miterLimit</a> 
    attribute) to be exceeded, this second triangle must not be added.</p> <!-- the actual ratio can't possibly be less than 1.0 -->


    <p>The subpaths in the newly created path must be oriented such that for any point, the number
    of times a half-infinite straight line drawn from that point crosses a subpath is even if and
    only if the number of times a half-infinite straight line drawn from that same point crosses a
    subpath going in one direction is equal to the number of times it crosses a subpath going in the
    other direction.</p>

   </li>

   <li><p>Return the newly created path.</p></li>

  </ol>

  </div>


 


